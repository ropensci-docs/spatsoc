[{"path":"https://docs.ropensci.org/spatsoc/CODE_OF_CONDUCT.html","id":null,"dir":"","previous_headings":"","what":"Contributor Code of Conduct","title":"Contributor Code of Conduct","text":"contributors maintainers project, pledge respect people contribute reporting issues, posting feature requests, updating documentation, submitting pull requests patches, activities. committed making participation project harassment-free experience everyone, regardless level experience, gender, gender identity expression, sexual orientation, disability, personal appearance, body size, race, ethnicity, age, religion. Examples unacceptable behavior participants include use sexual language imagery, derogatory comments personal attacks, trolling, public private harassment, insults, unprofessional conduct. Project maintainers right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct. Project maintainers follow Code Conduct may removed project team. Instances abusive, harassing, otherwise unacceptable behavior may reported opening issue contacting one project maintainers. Code Conduct adapted Contributor Covenant (http://contributor-covenant.org), version 1.0.0, available http://contributor-covenant.org/version/1/0/0/","code":""},{"path":"https://docs.ropensci.org/spatsoc/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contributing","title":"Contributing","text":"Development spatsoc welcomes contribution feature requests, bug reports suggested improvements issue board.","code":""},{"path":"https://docs.ropensci.org/spatsoc/CONTRIBUTING.html","id":"issues","dir":"","previous_headings":"","what":"Issues","title":"Contributing","text":"Use labels available Issue Board:","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":"https://docs.ropensci.org/spatsoc/CONTRIBUTING.html","id":"prefer-to-email","dir":"","previous_headings":"","what":"Prefer to Email?","title":"Contributing","text":"Email Alec Robitaille (see DESCRIPTION). Though note private discussions email don’t help others - course email totally warranted ’s sensitive problem kind.","code":""},{"path":"https://docs.ropensci.org/spatsoc/CONTRIBUTING.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of Conduct","title":"Contributing","text":"Please note spatsoc project released Contributor Code Conduct. contributing project agree abide terms.","code":""},{"path":"https://docs.ropensci.org/spatsoc/CONTRIBUTING.html","id":"thanks-for-contributing","dir":"","previous_headings":"","what":"Thanks for contributing!","title":"Contributing","text":"contributing guide adapted tidyverse contributing guide available https://raw.githubusercontent.com/r-lib/usethis/master/inst/templates/tidy-contributing.md","code":""},{"path":"https://docs.ropensci.org/spatsoc/articles/additional-data-formats.html","id":"multispecies-interactions","dir":"Articles","previous_headings":"","what":"Multispecies interactions","title":"Additional data formats","text":"Multispecies data can used spatsoc estimate interspecific interactions, eg. predator-prey dyanmics. Given two datasets movement data, simply bind together use group_* functions usual.","code":"predator <- fread(system.file(\"extdata\", \"DT_predator.csv\", package = \"spatsoc\")) prey <- fread(system.file(\"extdata\", \"DT_prey.csv\", package = \"spatsoc\"))  DT <- rbindlist(list(predator, prey))  # Set the datetime as a POSIxct DT[, datetime := as.POSIXct(datetime)]   # Temporal grouping group_times(DT, datetime = 'datetime', threshold = '10 minutes') #>           ID        X       Y            datetime population     type minutes #>       <char>    <num>   <num>              <POSc>      <int>   <char>   <int> #>    1:      B 708315.6 5460839 2016-11-30 14:00:45          1 predator       0 #>    2:      A 709764.2 5458231 2017-01-05 10:00:54          1 predator       0 #>    3:      B 709472.3 5460132 2016-12-03 08:00:42          1 predator       0 #>    4:      A 713630.5 5456393 2017-01-27 02:01:16          1 predator       0 #>    5:      B 707303.2 5461003 2016-12-17 18:00:54          1 predator       0 #>   ---                                                                         #> 5824:      G 708660.2 5459275 2017-02-28 14:00:44          1     prey       0 #> 5825:      G 708669.4 5459276 2017-02-28 16:00:42          1     prey       0 #> 5826:      G 708212.0 5458998 2017-02-28 18:00:53          1     prey       0 #> 5827:      G 708153.2 5458953 2017-02-28 20:00:12          1     prey       0 #> 5828:      G 708307.6 5459182 2017-02-28 22:00:46          1     prey       0 #>       timegroup #>           <int> #>    1:         1 #>    2:         2 #>    3:         3 #>    4:         4 #>    5:         5 #>   ---           #> 5824:      1422 #> 5825:      1423 #> 5826:      1424 #> 5827:      1425 #> 5828:      1440  # Spatial grouping group_pts(DT, threshold = 50, id = 'ID', coords = c('X', 'Y'), timegroup = 'timegroup') #>           ID        X       Y            datetime population     type minutes #>       <char>    <num>   <num>              <POSc>      <int>   <char>   <int> #>    1:      B 708315.6 5460839 2016-11-30 14:00:45          1 predator       0 #>    2:      A 709764.2 5458231 2017-01-05 10:00:54          1 predator       0 #>    3:      B 709472.3 5460132 2016-12-03 08:00:42          1 predator       0 #>    4:      A 713630.5 5456393 2017-01-27 02:01:16          1 predator       0 #>    5:      B 707303.2 5461003 2016-12-17 18:00:54          1 predator       0 #>   ---                                                                         #> 5824:      G 708660.2 5459275 2017-02-28 14:00:44          1     prey       0 #> 5825:      G 708669.4 5459276 2017-02-28 16:00:42          1     prey       0 #> 5826:      G 708212.0 5458998 2017-02-28 18:00:53          1     prey       0 #> 5827:      G 708153.2 5458953 2017-02-28 20:00:12          1     prey       0 #> 5828:      G 708307.6 5459182 2017-02-28 22:00:46          1     prey       0 #>       timegroup group #>           <int> <int> #>    1:         1     1 #>    2:         2     2 #>    3:         3     3 #>    4:         4     4 #>    5:         5     5 #>   ---                 #> 5824:      1422  5467 #> 5825:      1423  5468 #> 5826:      1424  5469 #> 5827:      1425  5470 #> 5828:      1440  5471   # Calculate the number of types within each group DT[, n_type := uniqueN(type), by = group] DT[, interact := n_type > 1]  # Prey's perspective sub_prey <- DT[type == 'prey'] sub_prey[, mean(interact)] #> [1] 0.01169693    # Plot -------------------------------------------------------------------- # If we subset only where there are interactions sub_interact <- DT[(interact)]  # Base R plot plot(sub_prey$X, sub_prey$Y, col = 'grey', pch = 21) points(sub_interact$X, sub_interact$Y, col = factor(sub_interact$type))"},{"path":"https://docs.ropensci.org/spatsoc/articles/faq.html","id":"usage","dir":"Articles","previous_headings":"","what":"Usage","title":"Frequently asked questions about spatsoc","text":"spatsoc leverages data.table modify reference iteratively work subsets input data. first input functions spatsoc DT, input data.table. data data.frame, can convert reference using setDT(DF).","code":""},{"path":"https://docs.ropensci.org/spatsoc/articles/faq.html","id":"spatial-and-temporal-grouping","dir":"Articles","previous_headings":"Usage","what":"Spatial and temporal grouping","title":"Frequently asked questions about spatsoc","text":"spatsoc designed work two steps: temporal followed either spatial grouping edge list generating. Considering specific study species system, determine relevant temporal spatial grouping threshold. may 5 minutes 50 meters 2 days 100 meters thresholds - functions provided spatsoc flexible user input. cases, spatial grouping function selected relevant certain temporal grouping thresholds. example, wouldn’t expect threshold 5 minutes group_polys.","code":"# Load packages library(spatsoc) library(data.table) # Read data as a data.table DT <- fread(system.file(\"extdata\", \"DT.csv\", package = \"spatsoc\"))  # Cast datetime column to POSIXct DT[, datetime := as.POSIXct(datetime)]  # Temporal groups group_times(DT, datetime = 'datetime', threshold = '5 minutes') ##            ID        X       Y            datetime population minutes timegroup ##        <char>    <num>   <num>              <POSc>      <int>   <int>     <int> ##     1:      A 715851.4 5505340 2016-11-01 00:00:54          1       0         1 ##     2:      A 715822.8 5505289 2016-11-01 02:01:22          1       0         2 ##     3:      A 715872.9 5505252 2016-11-01 04:01:24          1       0         3 ##     4:      A 715820.5 5505231 2016-11-01 06:01:05          1       0         4 ##     5:      A 715830.6 5505227 2016-11-01 08:01:11          1       0         5 ##    ---                                                                          ## 14293:      J 700616.5 5509069 2017-02-28 14:00:54          1       0      1393 ## 14294:      J 700622.6 5509065 2017-02-28 16:00:11          1       0      1394 ## 14295:      J 700657.5 5509277 2017-02-28 18:00:55          1       0      1449 ## 14296:      J 700610.3 5509269 2017-02-28 20:00:48          1       0      1395 ## 14297:      J 700744.0 5508782 2017-02-28 22:00:39          1       0      1396 # Spatial groups group_pts(   DT,   threshold = 50,   id = 'ID',   coords = c('X', 'Y'),   timegroup = 'timegroup' ) ##            ID        X       Y            datetime population minutes timegroup ##        <char>    <num>   <num>              <POSc>      <int>   <int>     <int> ##     1:      A 715851.4 5505340 2016-11-01 00:00:54          1       0         1 ##     2:      A 715822.8 5505289 2016-11-01 02:01:22          1       0         2 ##     3:      A 715872.9 5505252 2016-11-01 04:01:24          1       0         3 ##     4:      A 715820.5 5505231 2016-11-01 06:01:05          1       0         4 ##     5:      A 715830.6 5505227 2016-11-01 08:01:11          1       0         5 ##    ---                                                                          ## 14293:      J 700616.5 5509069 2017-02-28 14:00:54          1       0      1393 ## 14294:      J 700622.6 5509065 2017-02-28 16:00:11          1       0      1394 ## 14295:      J 700657.5 5509277 2017-02-28 18:00:55          1       0      1449 ## 14296:      J 700610.3 5509269 2017-02-28 20:00:48          1       0      1395 ## 14297:      J 700744.0 5508782 2017-02-28 22:00:39          1       0      1396 ##        group ##        <int> ##     1:     1 ##     2:     2 ##     3:     3 ##     4:     4 ##     5:     5 ##    ---       ## 14293:  9909 ## 14294:  9910 ## 14295:  9911 ## 14296:  9912 ## 14297:  9913"},{"path":"https://docs.ropensci.org/spatsoc/articles/faq.html","id":"social-network-analysis","dir":"Articles","previous_headings":"Usage","what":"Social network analysis","title":"Frequently asked questions about spatsoc","text":"See vignette using spatsoc social network analysis.","code":""},{"path":[]},{"path":[]},{"path":"https://docs.ropensci.org/spatsoc/articles/faq.html","id":"geos","dir":"Articles","previous_headings":"Installation > System dependencies","what":"GEOS","title":"Frequently asked questions about spatsoc","text":"Install GEOS: Debian/Ubuntu: apt-get install libgeos-dev Arch: pacman -S geos Fedora: dnf install geos geos-devel Mac: brew install geos Windows: see ","code":""},{"path":"https://docs.ropensci.org/spatsoc/articles/faq.html","id":"package-dependencies","dir":"Articles","previous_headings":"Installation","what":"Package dependencies","title":"Frequently asked questions about spatsoc","text":"data.table igraph sp adehabitatHR rgeos","code":""},{"path":[]},{"path":"https://docs.ropensci.org/spatsoc/articles/faq.html","id":"group_times","dir":"Articles","previous_headings":"Functions","what":"group_times","title":"Frequently asked questions about spatsoc","text":"group_times(DT, datetime, threshold) DT: input data.table datetime: date time column name input data.table threshold: threshold grouping","code":""},{"path":"https://docs.ropensci.org/spatsoc/articles/faq.html","id":"dt","dir":"Articles","previous_headings":"Functions > group_times","what":"DT","title":"Frequently asked questions about spatsoc","text":"data.table date time formatted column. input DT returned columns appended. timegroup column corresponds temporal group assigned row. Please note actual value time group meaningless. Reordered data return different time group. meaningful, however, contents group. group contain rows nearest threshold provided.","code":""},{"path":"https://docs.ropensci.org/spatsoc/articles/faq.html","id":"datetime-format","dir":"Articles","previous_headings":"Functions > group_times","what":"datetime format","title":"Frequently asked questions about spatsoc","text":"group_times function expects either one column (POSIXct) two columns (IDate ITime). Given character column representing date time, convert POSIXct IDate ITime: provided function using names column input data. group_times(DT, datetime = 'datetime', threshold = '5 minutes') group_times(DT, datetime = c('idate', 'itime'), threshold = '5 minutes')","code":"DT[, datetime := as.POSIXct(datetime)] DT[, c('idate', 'itime') := IDateTime(datetime)]"},{"path":"https://docs.ropensci.org/spatsoc/articles/faq.html","id":"threshold-recommendations","dir":"Articles","previous_headings":"Functions > group_times","what":"threshold recommendations","title":"Frequently asked questions about spatsoc","text":"threshold provided group_times related fix rate input dataset specific study system species. relocations recorded every two hours, threshold = '2 hours' group rows nearest two hour group (10am, 12pm, 2pm, 4pm, …). , however, means relocations can one hour apart . Picking smaller threshold, e.g.: threshold = '15 minutes' may relevant cases. flexibility spatsoc’s threshold argument means user must carefully consider threshold reasonable specific system.","code":""},{"path":"https://docs.ropensci.org/spatsoc/articles/faq.html","id":"limitations-of-threshold","dir":"Articles","previous_headings":"Functions > group_times","what":"Limitations of threshold","title":"Frequently asked questions about spatsoc","text":"threshold group_times considered within scope 24 hours poses limitations : threshold must evenly divide 60 minutes 24 hours multi-day blocks consistent across years timegroups year. number minutes exceed 60 threshold fractional","code":""},{"path":"https://docs.ropensci.org/spatsoc/articles/faq.html","id":"columns-returned-by-group_times","dir":"Articles","previous_headings":"Functions > group_times","what":"Columns returned by group_times","title":"Frequently asked questions about spatsoc","text":"main column returned group_times “timegroup”. represents temporal group row, nearest (either ) within threshold grouped. actual value meaning, contents group . means data reordered, row may different time group, rows group change. extra columns provided help user investigate, troubleshoot interpret timegroup.","code":""},{"path":"https://docs.ropensci.org/spatsoc/articles/faq.html","id":"warnings-and-messages","dir":"Articles","previous_headings":"Functions > group_times","what":"Warnings and messages","title":"Frequently asked questions about spatsoc","text":"“columns found input DT overwritten function” message returned user column matching returned group_times found input DT. commonly case group_times run multiple times consecutively. “threshold provided, using time field directly group” message returned user threshold NULL. default setting threshold , times, may suitable. case, date times datetime column grouped exactly. Usually, threshold provided. “minimum maximum days DT evenly divisible provided block length” warning returned user threshold unit days divide evenly range days DT. example, DT data covering 30 days, threshold ‘7 days’ used, warning returned. Note, warning returned range days entire data set year.","code":""},{"path":"https://docs.ropensci.org/spatsoc/articles/faq.html","id":"group_pts","dir":"Articles","previous_headings":"Functions","what":"group_pts","title":"Frequently asked questions about spatsoc","text":"group_pts(DT, threshold, id, coords, timegroup, splitBy) DT: input data.table threshold: threshold grouping id: column name IDs DT coords: column names x y coordinates DT timegroup: column name time group splitBy: (optional) column names extra variables group ","code":""},{"path":"https://docs.ropensci.org/spatsoc/articles/faq.html","id":"dt-1","dir":"Articles","previous_headings":"Functions > group_pts","what":"DT","title":"Frequently asked questions about spatsoc","text":"input data.table. returned column named group appended, represents spatial (temporal timegroup provided) group.","code":""},{"path":"https://docs.ropensci.org/spatsoc/articles/faq.html","id":"threshold","dir":"Articles","previous_headings":"Functions > group_pts","what":"threshold","title":"Frequently asked questions about spatsoc","text":"threshold must units coordinates.","code":""},{"path":"https://docs.ropensci.org/spatsoc/articles/faq.html","id":"coords","dir":"Articles","previous_headings":"Functions > group_pts","what":"coords","title":"Frequently asked questions about spatsoc","text":"coordinates must planar, UTM (whichever zone relocations ).","code":""},{"path":"https://docs.ropensci.org/spatsoc/articles/faq.html","id":"group_lines","dir":"Articles","previous_headings":"Functions","what":"group_lines","title":"Frequently asked questions about spatsoc","text":"group_lines(DT, threshold, projection, id, coords, timegroup, sortBy, splitBy, spLines) DT: input data.table threshold: threshold grouping projection: projection coordinates DT id: column name IDs DT coords: column names x y coordinates DT timegroup: (optional) column name time group sortBy: column name date time sort rows building lines splitBy: (optional) column names extra variables group sfLines: alternatively, provide sf LINESTRING object id column name","code":""},{"path":"https://docs.ropensci.org/spatsoc/articles/faq.html","id":"dt-2","dir":"Articles","previous_headings":"Functions > group_lines","what":"DT","title":"Frequently asked questions about spatsoc","text":"See 3.2.1.","code":""},{"path":"https://docs.ropensci.org/spatsoc/articles/faq.html","id":"threshold-1","dir":"Articles","previous_headings":"Functions > group_lines","what":"threshold","title":"Frequently asked questions about spatsoc","text":"threshold argument represents buffer area around line. threshold = 0, lines grouped spatial overlap. threshold greater 0, lines buffered, grouped spatial overlap.","code":""},{"path":"https://docs.ropensci.org/spatsoc/articles/faq.html","id":"projection","dir":"Articles","previous_headings":"Functions > group_lines","what":"projection","title":"Frequently asked questions about spatsoc","text":"projection argument expects character string numeric defining coordinate reference system passed sf::st_crs. example, UTM zone 36S (EPSG 32736), projection argument projection = \"EPSG:32736\" projection = 32736. See https://spatialreference.org list EPSG codes. Please note, R spatial followed updates GDAL PROJ handling projections, see https://r-spatial.org/r/2020/03/17/wkt.html.","code":""},{"path":"https://docs.ropensci.org/spatsoc/articles/faq.html","id":"sortby","dir":"Articles","previous_headings":"Functions > group_lines","what":"sortBy","title":"Frequently asked questions about spatsoc","text":"sortBy argument expects date time formatted column name, used order rows individual (splitBy).","code":""},{"path":"https://docs.ropensci.org/spatsoc/articles/faq.html","id":"group_polys","dir":"Articles","previous_headings":"Functions","what":"group_polys","title":"Frequently asked questions about spatsoc","text":"group_polys(DT, area, hrType, hrParams, projection, id, coords, splitBy, spLines) DT: input data.table area: boolean argument proportional area returned hrType: type home range created hrParams: parameters relevant type home range created projection: projection coordinates DT id: column name IDs DT coords: column names x y coordinates DT splitBy: (optional) column names extra variables group sfPolys: alternatively, provide simple features POLGON MULTIPOLYGON object id column","code":""},{"path":"https://docs.ropensci.org/spatsoc/articles/faq.html","id":"dt-and-area","dir":"Articles","previous_headings":"Functions > group_polys","what":"DT and area","title":"Frequently asked questions about spatsoc","text":"area = FALSE, see 3.2.1. area = TRUE, DT appended group column instead data.table IDs proportional area overlap returned. default unit area overlap square meters.","code":""},{"path":"https://docs.ropensci.org/spatsoc/articles/faq.html","id":"projection-1","dir":"Articles","previous_headings":"Functions > group_polys","what":"projection","title":"Frequently asked questions about spatsoc","text":"projection argument expects character string numeric defining coordinate reference system passed sf::st_crs. example, UTM zone 36S (EPSG 32736), projection argument projection = \"EPSG:32736\" projection = 32736. See https://spatialreference.org list EPSG codes. Please note, R spatial followed updates GDAL PROJ handling projections, see https://r-spatial.org/r/2020/03/17/wkt.html.","code":""},{"path":"https://docs.ropensci.org/spatsoc/articles/faq.html","id":"hrtype-and-hrparams","dir":"Articles","previous_headings":"Functions > group_polys","what":"hrType and hrParams","title":"Frequently asked questions about spatsoc","text":"Currently, spatsoc offers two types home ranges provided adehabitatHR package: ‘mcp’ (mcp) ‘kernel’ (kernelUD getverticeshr). parameters must match arguments functions. Internally, match arguments functions allowing user provide, example, percent (provided getverticeshr) grid arguments (provided mcp).","code":"group_polys(   DT,   area = FALSE,   projection = utm,   hrType = 'mcp',   hrParams = list(grid = 60, percent = 95),   id = 'ID',   coords = c('X', 'Y') )"},{"path":"https://docs.ropensci.org/spatsoc/articles/faq.html","id":"edge_dist","dir":"Articles","previous_headings":"Functions","what":"edge_dist","title":"Frequently asked questions about spatsoc","text":"edge_dist(DT = NULL, threshold = NULL, id = NULL, coords = NULL, timegroup = NULL, splitBy = NULL, fillNA = TRUE) DT: input data.table threshold: threshold grouping id: column name IDs DT coords: column names x y coordinates DT timegroup: column name time group splitBy: (optional) column names extra variables group fillNA: boolean indicating NAs returned individuals within threshold distance . TRUE, NAs returned. FALSE, edges individuals within threshold distance returned. non-chain rule implementation similar group_pts. Edges defined distance threshold NAs returned individuals within timegroup within threshold distance individual (fillNA TRUE). See vignette Using edge list generating functions dyad_id details edge_dist function.","code":""},{"path":"https://docs.ropensci.org/spatsoc/articles/faq.html","id":"edge_nn","dir":"Articles","previous_headings":"Functions","what":"edge_nn","title":"Frequently asked questions about spatsoc","text":"edge_nn(DT = NULL, id = NULL, coords = NULL, timegroup = NULL, splitBy = NULL, threshold = NULL) DT: input data.table id: column name IDs DT coords: column names x y coordinates DT timegroup: column name time group splitBy: (optional) column names extra variables group threshold: (optional) spatial distance threshold set maximum distance individual neighbour. function can used generate edge lists defined either nearest neighbour nearest neighbour maximum distance. NAs returned nearest neighbour individual alone timegroup (/splitBy) distance individual ’s nearest neighbour greater threshold. See vignette Using edge list generating functions dyad_id details edge_nn function.","code":""},{"path":"https://docs.ropensci.org/spatsoc/articles/faq.html","id":"randomizations","dir":"Articles","previous_headings":"Functions","what":"randomizations","title":"Frequently asked questions about spatsoc","text":"randomizations(DT, type, id, datetime, splitBy, iterations) DT: input data.table type: one ‘daily’, ‘step’ ‘trajectory’ id: Character string ID column name datetime: field used providing date time time group - see details splitBy: List fields DT split randomization process iterations: number iterations randomize See vignette Using spatsoc social network analysis details randomizations function (specifically section ‘Data stream randomization’)","code":""},{"path":[]},{"path":"https://docs.ropensci.org/spatsoc/articles/faq.html","id":"dont-i-need-to-reassign-to-save-the-output","dir":"Articles","previous_headings":"Package design","what":"Don’t I need to reassign to save the output?","title":"Frequently asked questions about spatsoc","text":"(Almost) functions spatsoc use data.table’s modify--reference reduce recopying large datasets improve performance. exceptions group_polys(area = TRUE), randomizations edge list generating functions edge_dist edge_nn.","code":""},{"path":"https://docs.ropensci.org/spatsoc/articles/faq.html","id":"why-does-a-function-print-the-result-but-columns-arent-added-to-my-dt","dir":"Articles","previous_headings":"Package design","what":"Why does a function print the result, but columns aren’t added to my DT?","title":"Frequently asked questions about spatsoc","text":"Check data.table columns allocated (data.table::truelength) , use data.table::setDT data.table::alloc.col. can happen reading data RDS RData files. See . simply:","code":"if (truelength(DT) == 0) {   setDT(DT) } # then go to spatsoc group_times(DT, datetime = 'datetime', threshold = '5 minutes') DT <- readRDS('path/to/data.Rds') alloc.col(DT)"},{"path":"https://docs.ropensci.org/spatsoc/articles/faq.html","id":"summary-information","dir":"Articles","previous_headings":"","what":"Summary information","title":"Frequently asked questions about spatsoc","text":"useful code chunks understanding spatial temporal extent data outputs spatsoc functions.","code":""},{"path":"https://docs.ropensci.org/spatsoc/articles/faq.html","id":"number-of-individuals","dir":"Articles","previous_headings":"Summary information","what":"Number of individuals","title":"Frequently asked questions about spatsoc","text":"","code":"# Number of unique individuals DT[, uniqueN(ID)]  # Number of unique individuals by timegroup DT[, uniqueN(ID), by = timegroup]"},{"path":"https://docs.ropensci.org/spatsoc/articles/faq.html","id":"temporal-range","dir":"Articles","previous_headings":"Summary information","what":"Temporal range","title":"Frequently asked questions about spatsoc","text":"","code":"# Min, max datetime DT[, range(datetime)]  # Difference between relocations in hours DT[order(datetime),     .(difHours = as.numeric(difftime(datetime, shift(datetime), units = 'hours'))),     by = ID]  # Difference between relocations in hours DT[order(datetime),     .(difMins = as.numeric(difftime(datetime, shift(datetime), units = 'mins'))),     by = ID]"},{"path":"https://docs.ropensci.org/spatsoc/articles/faq.html","id":"spatial-extent","dir":"Articles","previous_headings":"Summary information","what":"Spatial extent","title":"Frequently asked questions about spatsoc","text":"Simple spatial extents can calculated individuals individual.","code":"# All individuals DT[, .(minX = min(X),        maxX = max(X),        minY = min(Y),        maxY = max(Y),)]  # By individual DT[, .(minX = min(X),        maxX = max(X),        minY = min(Y),        maxY = max(Y),),    by = ID]"},{"path":"https://docs.ropensci.org/spatsoc/articles/faq.html","id":"spatsoc-outputs","dir":"Articles","previous_headings":"Summary information","what":"spatsoc outputs","title":"Frequently asked questions about spatsoc","text":"using grouping functions, can determine number individuals temporal spatial group.","code":"# Number of unique individuals by timegroup DT[, uniqueN(ID), by = timegroup]  # Number of unique individuals by group DT[, uniqueN(ID), by = group]"},{"path":"https://docs.ropensci.org/spatsoc/articles/intro-spatsoc.html","id":"data-preparation","dir":"Articles","previous_headings":"","what":"Data preparation","title":"Introduction to spatsoc","text":"spatsoc expects data.table functions. data.frame, can use data.table::setDT() convert reference. data CSV, can use data.table::fread() import data.table. data consist relocations 3 individuals 365 days. Using data, can compare various grouping methods available spatsoc. Note: examples use subset data, individuals H, J.","code":"# Load packages library(spatsoc) ## Note: spatsoc has been updated to follow the R-spatial evolution.  ## Package dependencies and some functions have been modified.  ## Please see the NEWS for details:  ## https://docs.ropensci.org/spatsoc/index.html#news library(data.table) # Read in spatsoc's example data DT <- fread(system.file(\"extdata\", \"DT.csv\", package = \"spatsoc\"))  # Use subset of individuals DT <- DT[ID %in% c('H', 'I', 'J')]  # Cast character column 'datetime' as POSIXct DT[, datetime := as.POSIXct(datetime, tz = 'UTC')] DT <- DT[ID %chin% c('H', 'I', 'J')]"},{"path":"https://docs.ropensci.org/spatsoc/articles/intro-spatsoc.html","id":"temporal-grouping","dir":"Articles","previous_headings":"","what":"Temporal grouping","title":"Introduction to spatsoc","text":"group_times function used group relocations temporally. flexible threshold provided units minutes, hours days. Since GPS fixes taken regular intervals level variability, provide time threshold (threshold), consider fixes within threshold taken time. Alternatively, may want understand different scales grouping, perhaps daily movement trajectories seasonal home range overlap. message returned group_times run DT, columns already exist input DT overwritten.","code":"group_times(DT, datetime = 'datetime', threshold = '5 minutes') group_times(DT, datetime = 'datetime', threshold = '2 hours') ## minutes, timegroup columns found in input DT and will be overwritten by this function group_times(DT, datetime = 'datetime', threshold = '5 days') ## hours, timegroup columns found in input DT and will be overwritten by this function"},{"path":"https://docs.ropensci.org/spatsoc/articles/intro-spatsoc.html","id":"spatial-grouping","dir":"Articles","previous_headings":"","what":"Spatial grouping","title":"Introduction to spatsoc","text":"group_pts function compares relocations individuals timegroup groups individuals based distance threshold provided user. group_pts function uses “chain rule” three individuals within defined threshold distance least one individual considered group. point based spatial grouping distance threshold use chain rule, see edge_dist . group_lines function groups individuals whose trajectories intersect specified time interval. represents coarser grouping method group_pts can help understand shared space daily, weekly temporal resolutions. group_polys function groups individuals whose home ranges intersect. represents coarsest grouping method, provide measure overlap across seasons, years available relocations. can either return proportion home range area overlapping individuals simple groups. Home ranges calculated using adehabitatHR::kernelUD adehabitatHR::mcp. Alternatively, simple features POLYGON MULTIPOLYGON object can provided sfPolys argument along id column.","code":"group_times(DT = DT, datetime = 'datetime', threshold = '15 minutes') group_pts(DT, threshold = 50, id = 'ID', coords = c('X', 'Y'), timegroup = 'timegroup') ## block, timegroup columns found in input DT and will be overwritten by this function utm <- 32736  group_times(DT = DT, datetime = 'datetime', threshold = '1 day') group_lines(DT, threshold = 50, projection = utm,              id = 'ID', coords = c('X', 'Y'),             timegroup = 'timegroup', sortBy = 'datetime') ## minutes, timegroup columns found in input DT and will be overwritten by this function ## group column will be overwritten by this function utm <- 32736 group_times(DT = DT, datetime = 'datetime', threshold = '8 days') group_polys(DT = DT, area = TRUE, hrType = 'mcp',            hrParams = list('percent' = 95),            projection = utm,            coords = c('X', 'Y'), id = 'ID') ## timegroup columns found in input DT and will be overwritten by this function ## Registered S3 methods overwritten by 'adehabitatMA': ##   method                       from ##   print.SpatialPixelsDataFrame sp   ##   print.SpatialPixels          sp"},{"path":"https://docs.ropensci.org/spatsoc/articles/intro-spatsoc.html","id":"edge-list-generation","dir":"Articles","previous_headings":"","what":"Edge list generation","title":"Introduction to spatsoc","text":"edge_dist function calculates geographic distance individuals within timegroup returns paired relocations within spatial threshold. edge_dist uses distance matrix like group_pts, , contrast, use chain rule group relocations. edge_nn function calculates nearest neighbour individual within time group. optional distance threshold provided, used limit maximum distance neighbours. edge_nn returns edge list individual nearest neighbour.","code":"group_times(DT = DT, datetime = 'datetime', threshold = '15 minutes') edge_dist(DT, threshold = 50, id = 'ID', coords = c('X', 'Y'), timegroup = 'timegroup', fillNA = TRUE) ## block, timegroup columns found in input DT and will be overwritten by this function group_times(DT = DT, datetime = 'datetime', threshold = '15 minutes') edge_nn(DT, id = 'ID', coords = c('X', 'Y'), timegroup = 'timegroup') ## minutes, timegroup columns found in input DT and will be overwritten by this function"},{"path":"https://docs.ropensci.org/spatsoc/articles/intro-spatsoc.html","id":"notes","dir":"Articles","previous_headings":"","what":"Notes","title":"Introduction to spatsoc","text":"Package dependencies spatsoc sp, rgeos, igraph, adehabitatHR data.table. data.table provides efficient methods manipulating large (small) datasets. result, input DT spatsoc functions must data.table isn’t, can simply use data.table::setDT(df) convert reference.","code":""},{"path":"https://docs.ropensci.org/spatsoc/articles/using-edge-and-dyad.html","id":"generate-edge-lists","dir":"Articles","previous_headings":"","what":"Generate edge lists","title":"Using edge list generating functions and dyad_id","text":"spatsoc provides users one temporal (group_times) two edge list generating functions (edge_dist, edge_nn) generate edge lists GPS relocations. Users can consider edges defined either spatial proximity individuals (edge_dist), nearest neighbour (edge_nn) nearest neighbour maximum distance (edge_nn). edge lists can used directly animal social network package asnipe generate networks.","code":""},{"path":"https://docs.ropensci.org/spatsoc/articles/using-edge-and-dyad.html","id":"load-packages-and-prepare-data","dir":"Articles","previous_headings":"Generate edge lists","what":"1. Load packages and prepare data","title":"Using edge list generating functions and dyad_id","text":"spatsoc expects data.table DT arguments date time columns formatted POSIXct. Next, group relocations temporally group_times generate edges lists one edge_dist, edge_dist. Note: mutually exclusive, select one edge list generating function time.","code":"## Load packages library(spatsoc) #> Note: spatsoc has been updated to follow the R-spatial evolution.  #> Package dependencies and some functions have been modified.  #> Please see the NEWS for details:  #> https://docs.ropensci.org/spatsoc/index.html#news library(data.table) ## Read data as a data.table DT <- fread(system.file(\"extdata\", \"DT.csv\", package = \"spatsoc\"))  ## Cast datetime column to POSIXct DT[, datetime := as.POSIXct(datetime)]"},{"path":"https://docs.ropensci.org/spatsoc/articles/using-edge-and-dyad.html","id":"a-edge_dist","dir":"Articles","previous_headings":"Generate edge lists","what":"2. a) edge_dist","title":"Using edge list generating functions and dyad_id","text":"Distance based edge lists relocations timegroup considered edges within spatial distance defined user threshold argument. Depending species study system, relevant temporal spatial distance thresholds used. case, relocations within 5 minutes 50 meters considered edges. non-chain rule implementation similar group_pts. Edges defined distance threshold NAs returned individuals within timegroup within threshold distance individual (fillNA TRUE). Optionally, edge_dist can return distances individuals (less threshold) column named ‘distance’ argument returnDist = TRUE.","code":"# Temporal groups group_times(DT, datetime = 'datetime', threshold = '5 minutes') #>            ID        X       Y            datetime population minutes timegroup #>        <char>    <num>   <num>              <POSc>      <int>   <int>     <int> #>     1:      A 715851.4 5505340 2016-11-01 00:00:54          1       0         1 #>     2:      A 715822.8 5505289 2016-11-01 02:01:22          1       0         2 #>     3:      A 715872.9 5505252 2016-11-01 04:01:24          1       0         3 #>     4:      A 715820.5 5505231 2016-11-01 06:01:05          1       0         4 #>     5:      A 715830.6 5505227 2016-11-01 08:01:11          1       0         5 #>    ---                                                                          #> 14293:      J 700616.5 5509069 2017-02-28 14:00:54          1       0      1393 #> 14294:      J 700622.6 5509065 2017-02-28 16:00:11          1       0      1394 #> 14295:      J 700657.5 5509277 2017-02-28 18:00:55          1       0      1449 #> 14296:      J 700610.3 5509269 2017-02-28 20:00:48          1       0      1395 #> 14297:      J 700744.0 5508782 2017-02-28 22:00:39          1       0      1396  # Edge list generation edges <- edge_dist(   DT,   threshold = 100,   id = 'ID',   coords = c('X', 'Y'),   timegroup = 'timegroup',   returnDist = TRUE,   fillNA = TRUE )"},{"path":"https://docs.ropensci.org/spatsoc/articles/using-edge-and-dyad.html","id":"b-edge_nn","dir":"Articles","previous_headings":"Generate edge lists","what":"2. b) edge_nn","title":"Using edge list generating functions and dyad_id","text":"Nearest neighbour based edge lists individual connected nearest neighbour. edge_nn can used generate edge lists defined either nearest neighbour nearest neighbour maximum distance. grouping functions edge_dist, temporal spatial threshold depend species study system. NAs returned nearest neighbour individual alone timegroup (/splitBy) distance individual nearest neighbour greater threshold. Optionally, edge_nn can return distances individuals (less threshold) column named ‘distance’ argument returnDist = TRUE.","code":"# Temporal groups group_times(DT, datetime = 'datetime', threshold = '5 minutes')  # Edge list generation edges <- edge_nn(   DT,   id = 'ID',   coords = c('X', 'Y'),   timegroup = 'timegroup' )  # Edge list generation using maximum distance threshold edges <- edge_nn(   DT,    id = 'ID',    coords = c('X', 'Y'),   timegroup = 'timegroup',    threshold = 100 )  # Edge list generation using maximum distance threshold, returning distances edges <- edge_nn(   DT,    id = 'ID',    coords = c('X', 'Y'),   timegroup = 'timegroup',    threshold = 100,   returnDist = TRUE )"},{"path":[]},{"path":"https://docs.ropensci.org/spatsoc/articles/using-edge-and-dyad.html","id":"dyad_id","dir":"Articles","previous_headings":"Dyads","what":"3. dyad_id","title":"Using edge list generating functions and dyad_id","text":"function dyad_id can used generate unique, undirected dyad identifier edge lists. generated dyad ids, can measure consecutive relocations, start end relocation, etc. Note: since edges duplicated -B B-, need use unique timegroup*dyadID divide counts 2.","code":"# In this case, using the edges generated in 2. a) edge_dist dyad_id(edges, id1 = 'ID1', id2 = 'ID2') #> Key: <timegroup, ID1> #>        timegroup    ID1    ID2  distance dyadID #>            <int> <char> <char>     <num> <char> #>     1:         1      A   <NA>        NA   <NA> #>     2:         1      B      G  5.782904    B-G #>     3:         1      C   <NA>        NA   <NA> #>     4:         1      D   <NA>        NA   <NA> #>     5:         1      E      H 65.061671    E-H #>    ---                                          #> 22942:      1457      G   <NA>        NA   <NA> #> 22943:      1458      H   <NA>        NA   <NA> #> 22944:      1459      I   <NA>        NA   <NA> #> 22945:      1460      J   <NA>        NA   <NA> #> 22946:      1461      J   <NA>        NA   <NA>"},{"path":"https://docs.ropensci.org/spatsoc/articles/using-edge-and-dyad.html","id":"dyad-stats","dir":"Articles","previous_headings":"Dyads","what":"4. Dyad stats","title":"Using edge list generating functions and dyad_id","text":"","code":"# Get the unique dyads by timegroup # NOTE: we are explicitly selecting only where dyadID is not NA dyads <- unique(edges[!is.na(dyadID)], by = c('timegroup', 'dyadID'))  # NOTE: if we wanted to also include where dyadID is NA, we should do it explicitly # dyadNN <- unique(DT[!is.na(NN)], by = c('timegroup', 'dyadID'))  # Get where NN was NA # dyadNA <- DT[is.na(NN)]  # Combine where NN is NA # dyads <- rbindlist(list(dyadNN, dyadNA))   # Set the order of the rows setorder(dyads, timegroup)  ## Count number of timegroups dyads are observed together dyads[, nObs := .N, by = .(dyadID)]  ## Count consecutive relocations together # Shift the timegroup within dyadIDs dyads[, shifttimegrp := shift(timegroup, 1), by =  dyadID]  # Difference between consecutive timegroups for each dyadID # where difftimegrp == 1, the dyads remained together in consecutive timegroups dyads[, difftimegrp := timegroup - shifttimegrp]   # Run id of diff timegroups dyads[, runid := rleid(difftimegrp), by = dyadID]  # N consecutive observations of dyadIDs dyads[, runCount := fifelse(difftimegrp == 1, .N, NA_integer_), by = .(runid, dyadID)]  ## Start and end of consecutive relocations for each dyad # Dont consider where runs aren't more than one relocation dyads[runCount > 1, start := fifelse(timegroup == min(timegroup), TRUE, FALSE), by = .(runid, dyadID)]  dyads[runCount > 1, end := fifelse(timegroup == max(timegroup), TRUE, FALSE), by = .(runid, dyadID)]  ## Example output dyads[dyadID == 'B-H',        .(timegroup, nObs, shifttimegrp, difftimegrp, runid, runCount, start, end)] #>     timegroup  nObs shifttimegrp difftimegrp runid runCount  start    end #>         <int> <int>        <int>       <int> <int>    <int> <lgcl> <lgcl> #>  1:      1340    29           NA          NA     1       NA     NA     NA #>  2:      1341    29         1340           1     2        3   TRUE  FALSE #>  3:      1342    29         1341           1     2        3  FALSE  FALSE #>  4:      1343    29         1342           1     2        3  FALSE   TRUE #>  5:      1346    29         1343           3     3       NA     NA     NA #>  6:      1347    29         1346           1     4        3   TRUE  FALSE #>  7:      1348    29         1347           1     4        3  FALSE  FALSE #>  8:      1349    29         1348           1     4        3  FALSE   TRUE #>  9:      1351    29         1349           2     5       NA     NA     NA #> 10:      1356    29         1351           5     6       NA     NA     NA #> 11:      1357    29         1356           1     7        2   TRUE  FALSE #> 12:      1358    29         1357           1     7        2  FALSE   TRUE #> 13:      1360    29         1358           2     8       NA     NA     NA #> 14:      1361    29         1360           1     9        1     NA     NA #> 15:      1364    29         1361           3    10       NA     NA     NA #> 16:      1383    29         1364          19    11       NA     NA     NA #> 17:      1384    29         1383           1    12        7   TRUE  FALSE #> 18:      1385    29         1384           1    12        7  FALSE  FALSE #> 19:      1386    29         1385           1    12        7  FALSE  FALSE #> 20:      1387    29         1386           1    12        7  FALSE  FALSE #> 21:      1388    29         1387           1    12        7  FALSE  FALSE #> 22:      1389    29         1388           1    12        7  FALSE  FALSE #> 23:      1390    29         1389           1    12        7  FALSE   TRUE #> 24:      1392    29         1390           2    13       NA     NA     NA #> 25:      1393    29         1392           1    14        3   TRUE  FALSE #> 26:      1394    29         1393           1    14        3  FALSE  FALSE #> 27:      1395    29         1394           1    14        3  FALSE   TRUE #> 28:      1445    29         1395          50    15       NA     NA     NA #> 29:      1446    29         1445           1    16        1     NA     NA #>     timegroup  nObs shifttimegrp difftimegrp runid runCount  start    end"},{"path":"https://docs.ropensci.org/spatsoc/articles/using-in-sna.html","id":"generate-gambit-of-the-group-data","dir":"Articles","previous_headings":"","what":"Generate gambit of the group data","title":"Using spatsoc in social network analysis - grouping functions","text":"spatsoc provides users one temporal (group_times) three spatial (group_pts, group_lines, group_polys) functions generate gambit group data GPS relocations. Users can consider spatial grouping three different scales combined appropriate temporal grouping threshold. gambit group data used generate group individual matrix build network.","code":""},{"path":"https://docs.ropensci.org/spatsoc/articles/using-in-sna.html","id":"load-packages-and-prepare-data","dir":"Articles","previous_headings":"Generate gambit of the group data","what":"1. Load packages and prepare data","title":"Using spatsoc in social network analysis - grouping functions","text":"spatsoc expects data.table DT arguments date time columns formatted POSIXct. Next, group relocations temporally group_times spatially one group_pts, group_lines, group_polys. Note: mutually exclusive, select one spatial grouping function time.","code":"## Load packages library(spatsoc) library(data.table) library(asnipe) library(igraph) ## Read data as a data.table DT <- fread(system.file(\"extdata\", \"DT.csv\", package = \"spatsoc\"))  ## Cast datetime column to POSIXct DT[, datetime := as.POSIXct(datetime)]  ## Calculate the year of the relocation  DT[, yr := year(datetime)]"},{"path":"https://docs.ropensci.org/spatsoc/articles/using-in-sna.html","id":"a-group_pts","dir":"Articles","previous_headings":"Generate gambit of the group data","what":"2. a) group_pts","title":"Using spatsoc in social network analysis - grouping functions","text":"Point based grouping calculating distance relocations timegroup. Depending species study system, relevant temporal spatial grouping thresholds used. case, relocations within 5 minutes 50 meters grouped together.","code":"## Temporal groups group_times(DT, datetime = 'datetime', threshold = '5 minutes')  ## Spatial groups group_pts(   DT,   threshold = 50,   id = 'ID',   coords = c('X', 'Y'),   timegroup = 'timegroup' )"},{"path":"https://docs.ropensci.org/spatsoc/articles/using-in-sna.html","id":"b-group_lines","dir":"Articles","previous_headings":"Generate gambit of the group data","what":"2. b) group_lines","title":"Using spatsoc in social network analysis - grouping functions","text":"Line based grouping measuring intersection , optionally buffered, trajectories individual timegroup. Longer temporal thresholds used measure, example, intersecting daily trajectories.","code":"# EPSG code for relocations utm <- 32736  ## Group relocations by julian day group_times(DT, datetime = 'datetime', threshold = '1 day')  ## Group lines for each individual and julian day group_lines(   DT,   threshold = 50,   projection = utm,   id = 'ID',   coords = c('X', 'Y'),   timegroup = 'timegroup',   sortBy = 'datetime' )"},{"path":"https://docs.ropensci.org/spatsoc/articles/using-in-sna.html","id":"c-group_polys","dir":"Articles","previous_headings":"Generate gambit of the group data","what":"2. c) group_polys","title":"Using spatsoc in social network analysis - grouping functions","text":"Polygon based grouping generating home ranges using adehabitatHR measuring intersection proportional overlap. Longer temporal thresholds used create seasonal, monthly, yearly home ranges.","code":"# EPSG code for relocations utm <- 32736  ## Option 1: area = FALSE and home range intersection 'group' column added to DT  group_polys(   DT,   area = FALSE,   hrType = 'mcp',   hrParams = list(percent = 95),   projection = utm,   id = 'ID',   coords = c('X', 'Y') )  ## Option 2: area = TRUE  #  results must be assigned to a new variable  #  data.table returned has ID1, ID2 and proportion and area overlap areaDT <- group_polys(   DT,   area = TRUE,   hrType = 'mcp',   hrParams = list(percent = 95),   projection = utm,   id = 'ID',   coords = c('X', 'Y') )"},{"path":"https://docs.ropensci.org/spatsoc/articles/using-in-sna.html","id":"build-observed-network","dir":"Articles","previous_headings":"","what":"Build observed network","title":"Using spatsoc in social network analysis - grouping functions","text":"’ve generated groups using group_times one spatial grouping functions, can generate group individual matrix. following code chunk showing get_gbi can used outputs group_pts, group_lines group_polys(area = FALSE). purpose vignette however, consider outputs group_pts (2. )) following code chunk. Note: show example creating group individual matrix network 2016 illustrate spatsoc can used simpler data splitting temporal spatial subgroups (e.g.: yearly, population). See random network section use spatsoc social network analysis multi-year complex data.","code":""},{"path":"https://docs.ropensci.org/spatsoc/articles/using-in-sna.html","id":"get_gbi","dir":"Articles","previous_headings":"Build observed network","what":"3. get_gbi","title":"Using spatsoc in social network analysis - grouping functions","text":"Note: spatsoc::get_gbi identical function asnipe::get_group_by_individual, efficient (benchmarks measuring >10x improvements) thanks data.table::dcast.","code":"## Subset DT to only year 2016 subDT <- DT[yr == 2016]  ## Generate group by individual matrix # group column generated by spatsoc::group_pts gbiMtrx <- get_gbi(DT = subDT, group = 'group', id = 'ID')"},{"path":"https://docs.ropensci.org/spatsoc/articles/using-in-sna.html","id":"asnipeget_network","dir":"Articles","previous_headings":"Build observed network","what":"4. asnipe::get_network","title":"Using spatsoc in social network analysis - grouping functions","text":"Next, can use asnipe::get_network build observed social network. Ensure argument “data_format” “GBI”. Use arguments relevant analysis, calculate Simple ratio index.","code":"## Generate observed network net <- get_network(gbiMtrx,                    data_format = \"GBI\",                    association_index = \"SRI\")"},{"path":"https://docs.ropensci.org/spatsoc/articles/using-in-sna.html","id":"data-stream-randomization","dir":"Articles","previous_headings":"","what":"Data stream randomization","title":"Using spatsoc in social network analysis - grouping functions","text":"Three types data stream randomization provided spatsoc’s randomizations function: step: randomizes identities relocations individuals within time step. daily: randomizes identities relocations individuals within day. trajectory: randomizes daily trajectories within individuals (Spiegel et al. 2016). results randomizations must assigned. function returns id datetime columns provided (anything provided splitBy). addition, columns ‘observed’ ‘iteration’ returned indicating observed rows iteration rows correspond (0 observed). spatial grouping functions, methods mutually exclusive. Pick one type rebuild network randomization. Note: coords argument required trajectory type randomization, since randomizing method, ‘coords’ needed redo spatial grouping (group_pts, group_lines group_polys).","code":""},{"path":"https://docs.ropensci.org/spatsoc/articles/using-in-sna.html","id":"a-type-step","dir":"Articles","previous_headings":"Data stream randomization","what":"5. a) type = 'step'","title":"Using spatsoc in social network analysis - grouping functions","text":"'step' randomizes identities relocations individuals within time step. datetime argument expects integer group generated group_times. group argument expects column name group generated spatial grouping functions. Four columns returned type = 'step' along id, datetime splitBy columns: ‘randomID’ - randomly selected ID IDs within time step ‘observed’ - observed rows (TRUE/FALSE) ‘iteration’ - iteration rows correspond (0 observed)","code":"# Calculate year column to ensure randomization only occurs within years since data spans multiple years DT[, yr := year(datetime)]  ## Step type randomizations #  providing 'timegroup' (from group_times) as datetime #  splitBy = 'yr' to force randomization only within year randStep <- randomizations(    DT,    type = 'step',    id = 'ID',    group = 'group',    coords = NULL,    datetime = 'timegroup',    iterations = 3,    splitBy = 'yr' )"},{"path":"https://docs.ropensci.org/spatsoc/articles/using-in-sna.html","id":"b-type-daily","dir":"Articles","previous_headings":"Data stream randomization","what":"5. b) type = 'daily'","title":"Using spatsoc in social network analysis - grouping functions","text":"'daily' randomizes identities relocations individuals within day. datetime argument expects datetime POSIXct format column. Four columns returned type = 'daily' along id, datetime splitBy columns: ‘randomID’ - randomly selected ID day ‘jul’ - julian day ‘observed’ - observed rows (TRUE/FALSE) ‘iteration’ - iteration rows correspond (0 observed)","code":"# Calculate year column to ensure randomization only occurs within years since data spans multiple years DT[, yr := year(datetime)]  ## Daily type randomizations # splitBy = 'yr' to force randomization only within year randDaily <- randomizations(    DT,    type = 'daily',    id = 'ID',    group = 'group',    coords = NULL,    datetime = 'datetime',    splitBy = 'yr',    iterations = 20 )"},{"path":"https://docs.ropensci.org/spatsoc/articles/using-in-sna.html","id":"c-type-trajectory","dir":"Articles","previous_headings":"Data stream randomization","what":"5. c) type = 'trajectory'","title":"Using spatsoc in social network analysis - grouping functions","text":"'trajectory' randomizes daily trajectories within individuals (Spiegel et al. 2016). datetime argument expects datetime POSIXct format column. Five columns returned type = 'trajectory' along id, datetime splitBy columns: random date time (“random” prefixed datetime argument) ‘jul’ - observed julian day ‘observed’ - observed rows (TRUE/FALSE) ‘iteration’ - iteration rows correspond (0 observed) ‘randomJul’ - random julian day relocations swapped observed julian day","code":"# Calculate year column to ensure randomization only occurs within years since data spans multiple years DT[, yr := year(datetime)]  ## Trajectory type randomization randTraj <- randomizations(    DT,    type = 'trajectory',    id = 'ID',    group = NULL,    coords = c('X', 'Y'),    datetime = 'datetime',    splitBy = 'yr',    iterations = 20 )"},{"path":"https://docs.ropensci.org/spatsoc/articles/using-in-sna.html","id":"build-random-network","dir":"Articles","previous_headings":"","what":"Build random network","title":"Using spatsoc in social network analysis - grouping functions","text":"’ve randomized data stream randomizations, can build random network. use get_gbi function directly type either ‘step’ ‘daily’. type = 'trajectory', recalculate spatial groups one group_pts, group_lines, group_polys randomized data. case, example shows group_pts. Since want create group individual matrix random iteration (case, year), use mapply work subsets randomized data. Note: building random networks depends type used therefore, following chunks mutually exclusive. Use one corresponds randomization type used .","code":""},{"path":"https://docs.ropensci.org/spatsoc/articles/using-in-sna.html","id":"a-type-step-1","dir":"Articles","previous_headings":"Build random network","what":"6. a) type = 'step'","title":"Using spatsoc in social network analysis - grouping functions","text":"randomizations type = 'step' returns ‘randomID’ used instead observed ‘ID’ generate group individual matrix. get_gbi, use asnipe::get_network build random network.","code":"## Create a data.table of unique combinations of iteration and year, excluding observed rows iterYearLs <- unique(randStep[!(observed), .(iteration, yr)])  ## Generate group by individual matrix  # for each combination of iteration number and year # 'group' generated by spatsoc::group_pts # 'randomID' used instead of observed ID (type = 'step') gbiLs <- mapply(FUN = function(i, y) {   get_gbi(randStep[iteration == i & yr == y],           'group', 'randomID')   },   i = iterYearLs$iter,   y = iterYearLs$yr,   SIMPLIFY = FALSE )  ## Generate a list of random networks netLs <- lapply(gbiLs, FUN = get_network,                 data_format = \"GBI\", association_index = \"SRI\")"},{"path":"https://docs.ropensci.org/spatsoc/articles/using-in-sna.html","id":"b-type-daily-1","dir":"Articles","previous_headings":"Build random network","what":"6. b) type = 'daily'","title":"Using spatsoc in social network analysis - grouping functions","text":"randomizations type = 'step' returns ‘randomID’ used instead observed ‘ID’ generate group individual matrix. get_gbi, use asnipe::get_network build random network. case, generate fake column representing “population” show can translate mapply chunk three (variables).","code":"## Generate fake population randDaily[, population := sample(1:2, .N, replace = TRUE)]  ## Create a data.table of unique combinations of iteration, year, and population, excluding observed rows iterYearLs <- unique(randStep[!(observed), .(iteration, yr, population)])  ## Generate group by individual matrix  # for each combination of iteration number and year # 'group' generated by spatsoc::group_pts # 'randomID' used instead of observed ID (type = 'step') gbiLs <- mapply(FUN = function(i, y, p) {   get_gbi(randDaily[iteration == i &                        yr == y & population == p],           'group', 'randomID')   },   i = iterYearLs$iter,   y = iterYearLs$yr,   p = iterYearLs$population,   SIMPLIFY = FALSE )  ## Generate a list of random networks netLs <- lapply(gbiLs, FUN = get_network,                 data_format = \"GBI\", association_index = \"SRI\")"},{"path":"https://docs.ropensci.org/spatsoc/articles/using-in-sna.html","id":"c-type-trajectory-1","dir":"Articles","previous_headings":"Build random network","what":"6. c) type = 'trajectory'","title":"Using spatsoc in social network analysis - grouping functions","text":"randomizations type = 'trajectory' returns random date time used instead observed date time generate random gambit group data. First, pass randomized data group_times using random date time datetime. get_gbi, use asnipe::get_network build random network.","code":"## Randomized temporal groups # 'datetime' is the randomdatetime produced by randomizations(type = 'trajectory') group_times(randTraj, datetime = 'randomdatetime', threshold = '5 minutes')  ## Randomized spatial groups # 'iteration' used in splitBy to ensure only points within each iteration are grouped group_pts(randTraj, threshold = 50, id = 'ID', coords = c('X', 'Y'),           timegroup = 'timegroup', splitBy = 'iteration')  ## Create a data.table of unique combinations of iteration and year, excluding observed rows iterYearLs <- unique(randStep[!(observed), .(iteration, yr)])  ## Generate group by individual matrix  # for each combination of iteration number and year # 'group' generated by spatsoc::group_pts # 'ID' used since datetimes were randomized within individuals gbiLs <- mapply(FUN = function(i, y) {   get_gbi(randTraj[iteration == i & yr == y],           'group', 'ID')   },   i = iterYearLs$iter,   y = iterYearLs$yr,   SIMPLIFY = FALSE )  ## Generate a list of random networks netLs <- lapply(gbiLs, FUN = get_network,                 data_format = \"GBI\", association_index = \"SRI\")"},{"path":"https://docs.ropensci.org/spatsoc/articles/using-in-sna.html","id":"network-metrics","dir":"Articles","previous_headings":"","what":"Network metrics","title":"Using spatsoc in social network analysis - grouping functions","text":"Finally, can calculate network metrics. Please note many ways interpreting, analyzing measuring networks, simply show one option.","code":""},{"path":"https://docs.ropensci.org/spatsoc/articles/using-in-sna.html","id":"calculate-observed-network-metrics","dir":"Articles","previous_headings":"Network metrics","what":"7. Calculate observed network metrics","title":"Using spatsoc in social network analysis - grouping functions","text":"calculate observed network metrics, use network (net) produced 4. 2016 data.","code":"## Generate graph g <- graph.adjacency(net, 'undirected',                       diag = FALSE, weighted = TRUE)  ## Metrics for all individuals  observed <- data.table(   centrality = evcent(g)$vector,   strength = graph.strength(g),   degree = degree(g),   ID = names(degree(g)),   yr = subDT[, unique(yr)] )"},{"path":"https://docs.ropensci.org/spatsoc/articles/using-in-sna.html","id":"calculate-random-network-metrics","dir":"Articles","previous_headings":"Network metrics","what":"8. Calculate random network metrics","title":"Using spatsoc in social network analysis - grouping functions","text":"list random networks 6., can generate list graphs igraph::graph.adjacency (example) calculate random network metrics. example uses netLs generated 6. ) split year iteration.","code":"## Generate graph and calculate network metrics mets <- lapply(seq_along(netLs), function(n) {   g <- graph.adjacency(netLs[[n]], 'undirected',                         diag = FALSE, weighted = TRUE)      data.table(     centrality = evcent(g)$vector,     strength = graph.strength(g),     degree = degree(g),     ID = names(degree(g)),     iteration = iterYearLs$iter[[n]],     yr = iterYearLs$yr[[n]]     ) })  ## Metrics for all individuals across all iterations and years random <- rbindlist(mets)  ## Mean values for each individual and year meanMets <- random[, lapply(.SD, mean), by = .(ID, yr),                 .SDcols = c('centrality', 'strength', 'degree')]"},{"path":"https://docs.ropensci.org/spatsoc/articles/using-in-sna.html","id":"compare-observed-and-random-metrics","dir":"Articles","previous_headings":"Network metrics","what":"9. Compare observed and random metrics","title":"Using spatsoc in social network analysis - grouping functions","text":"Instead calculating observed random metrics separately (shown 7. 8.), can calculate metrics time compare. chunk expects outputs 5. ), skipping steps 6.-8. Note: removing !(observed) subset randStep performed 6. ), include observed rows iteration == 0. return gbiLs observed random rows included data.table.","code":"## Create a data.table of unique combinations of iteration and year, including observed and random rows iterYearLs <- unique(randStep[, .(iteration, yr)])  ## Generate group by individual matrix  # for each combination of iteration and year # 'group' generated by spatsoc::group_pts # 'randomID' used instead of observed ID (type = 'step') gbiLs <- mapply(FUN = function(i, y) {   get_gbi(randStep[iteration == i & yr == y],           'group', 'randomID')   },   i = iterYearLs$iter,   y = iterYearLs$yr,   SIMPLIFY = FALSE )  ## Generate a list of random networks netLs <- lapply(gbiLs, FUN = get_network,                 data_format = \"GBI\", association_index = \"SRI\")  ## Generate graph and calculate network metrics mets <- lapply(seq_along(netLs), function(n) {   g <- graph.adjacency(netLs[[n]], 'undirected',                         diag = FALSE, weighted = TRUE)      data.table(     centrality = evcent(g)$vector,     strength = graph.strength(g),     ID = names(degree(g)),     iteration = iterYearLs$iter[[n]],     yr = iterYearLs$yr[[n]]     ) })  ## Observed and random for all individuals across all iterations and years out <- rbindlist(mets)  ## Split observed and random out[, observed := ifelse(iteration == 0, TRUE, FALSE)]  ## Mean values for each individual and year, by observed/random meanMets <- out[, lapply(.SD, mean), by = .(ID, yr, observed),                 .SDcols = c('centrality', 'strength')]"},{"path":"https://docs.ropensci.org/spatsoc/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Alec L. Robitaille. Author, maintainer. Quinn Webber. Author. Eric Vander Wal. Author.","code":""},{"path":"https://docs.ropensci.org/spatsoc/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Alec L. Robitaille, Quinn M.R. Webber, Eric Vander Wal (2019). Conducting social network analysis animal telemetry data: applications methods using spatsoc. Methods Ecology Evolution. URL https://doi.org/10.1111/2041-210X.13215","code":"@Article{,   title = {Conducting social network analysis with animal telemetry data: applications and methods using {spatsoc}},   author = {Alec L Robitaille and Quinn MR Webber and Eric Vander Wal},   journal = {Methods in Ecology and Evolution},   year = {2019},   url = {https://doi.org/10.1111/2041-210X.13215}, }"},{"path":[]},{"path":"https://docs.ropensci.org/spatsoc/index.html","id":"news---installation---usage---contributing","dir":"","previous_headings":"","what":"News - Installation - Usage - Contributing","title":"Group Animal Relocation Data by Spatial and Temporal Relationship","text":"spatsoc R package detecting spatial temporal groups GPS relocations. can used convert GPS relocations gambit---group format build proximity-based social networks grouping edge-list generating functions. addition, randomizations function provides data-stream randomization methods suitable GPS data get_gbi function generates group individual matrices useful building networks asnipe::get_network. See installation basic usage. details, see blog post vignettes: Introduction spatsoc Frequently asked questions Using spatsoc social network analysis Using edge list dyad id functions","code":""},{"path":[]},{"path":"https://docs.ropensci.org/spatsoc/index.html","id":"r-spatial-evolution","dir":"","previous_headings":"News","what":"R-spatial evolution","title":"Group Animal Relocation Data by Spatial and Temporal Relationship","text":"spatsoc updated according R-spatial evolution, remove deprecated package dependencies favour modern spatial R packages. case, means replacing rgeos, rgdal sp sf. list user-side differences spatsoc users: spatsoc now depends sf, units instead rgeos sp build_lines now returns sf LINESTRING object build_polys now returns sf POLYGON/MULTIPOLYGON object group_lines now accepts input sf LINESTRING object (argument “sfLines”) internally uses sf::st_intersects, sf::st_buffer, etc instead rgeos functions group_polys now accepts input sf POLYGON/MULTIPOLYGON object (argument “sfPolys”) internally uses sf::st_intersects, sf::st_area, etc instead rgeos functions. group_polys now returns area proportion overlap (%) area = TRUE respective units using units package details changes available PR 50. required, old version using retired spatial packages can installed following please note October 2023 rgeos, rgdal maptools longer available CRAN. wrote targets workflow, available github.com/robitalec/targets-spatsoc-networks. targets incredible package designing workflows R , , can reproducibly run steps raw telemetry data output networks metrics. Check let us know works ! Edge-list generating functions added: edge_nn edge_dist dyad id function: dyad_id (feedback welcome always!) documented vignette: Using edge list dyad id functions. Also, article describing spatsoc published Methods Ecology Evolution. Link . Thanks reviewers editors rOpenSci MEE. detailed news .","code":"remotes::install_github('ropensci/spatsoc@v0.1.17')"},{"path":"https://docs.ropensci.org/spatsoc/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Group Animal Relocation Data by Spatial and Temporal Relationship","text":"spatsoc depends sf, see help installing.","code":"# Stable release install.packages('spatsoc')  # Development version (choose one option) install.packages('spatsoc',                   repos = c('https://robitalec.r-universe.dev',                            'https://cloud.r-project.org')) remotes::install_github('ropensci/spatsoc')"},{"path":[]},{"path":"https://docs.ropensci.org/spatsoc/index.html","id":"load-package-import-data","dir":"","previous_headings":"Usage","what":"Load package, import data","title":"Group Animal Relocation Data by Spatial and Temporal Relationship","text":"spatsoc expects data.table functions. data.frame, can use data.table::setDT() convert reference. data text file (e.g.: CSV), can use data.table::fread() import data.table.","code":"library(spatsoc) library(data.table) DT <- fread(system.file(\"extdata\", \"DT.csv\", package = \"spatsoc\")) DT[, datetime := as.POSIXct(datetime, tz = 'UTC')]"},{"path":"https://docs.ropensci.org/spatsoc/index.html","id":"temporal-grouping","dir":"","previous_headings":"Usage","what":"Temporal grouping","title":"Group Animal Relocation Data by Spatial and Temporal Relationship","text":"group_times groups rows temporally using threshold defined units minutes (B), hours (C) days (D).","code":""},{"path":"https://docs.ropensci.org/spatsoc/index.html","id":"spatial-grouping","dir":"","previous_headings":"Usage","what":"Spatial grouping","title":"Group Animal Relocation Data by Spatial and Temporal Relationship","text":"group_pts groups points spatially using distance matrix (B) spatial threshold defined user (50m case). Combined group_times, returned ‘group’ column represents spatiotemporal, point based groups (D).  group_lines groups sequences points (forming line) spatially buffering line () user defined spatial threshold. Combined group_times, returned ‘group’ column represents spatiotemporal, line overlap based groups (B).  group_polys groups home ranges spatial proportional overlap. Combined group_times, returned ‘group’ column represents spatiotemporal, polygon overlap based groups.","code":""},{"path":"https://docs.ropensci.org/spatsoc/index.html","id":"edge-list-generating-functions","dir":"","previous_headings":"Usage","what":"Edge-list generating functions","title":"Group Animal Relocation Data by Spatial and Temporal Relationship","text":"edge_dist edge_nn generate edge-lists. edge_dist measures spatial distance individuals () returns pairs within user specified distance threshold (B). edge_nn measures distance individuals (C) returns nearest neighbour individual (D).","code":""},{"path":"https://docs.ropensci.org/spatsoc/index.html","id":"social-network-analysis-functions","dir":"","previous_headings":"Usage","what":"Social network analysis functions","title":"Group Animal Relocation Data by Spatial and Temporal Relationship","text":"randomizations data-stream randomization get_gbi generating group individual matrices.","code":""},{"path":"https://docs.ropensci.org/spatsoc/index.html","id":"contributing","dir":"","previous_headings":"","what":"Contributing","title":"Group Animal Relocation Data by Spatial and Temporal Relationship","text":"Please note project released Contributor Code Conduct. participating project agree abide terms. Development spatsoc welcomes contribution feature requests, bug reports suggested improvements issue board. See details CONTRIBUTING.md.","code":""},{"path":"https://docs.ropensci.org/spatsoc/reference/DT.html","id":null,"dir":"Reference","previous_headings":"","what":"Movement of 10 ","title":"Movement of 10 ","text":"dataset containing GPS relocations 10 individuals winter 2016-2017.","code":""},{"path":"https://docs.ropensci.org/spatsoc/reference/DT.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Movement of 10 ","text":"data.table 14297 rows 5 variables: ID individual identifier X X coordinate relocation (UTM 36N) Y Y coordinate relocation (UTM 36N) datetime character string representing date time population sub population within individuals","code":""},{"path":"https://docs.ropensci.org/spatsoc/reference/DT.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Movement of 10 ","text":"","code":"# Load data.table library(data.table) data.table::setDTthreads(1)  # Read example data DT <- fread(system.file(\"extdata\", \"DT.csv\", package = \"spatsoc\"))"},{"path":"https://docs.ropensci.org/spatsoc/reference/build_lines.html","id":null,"dir":"Reference","previous_headings":"","what":"Build Lines — build_lines","title":"Build Lines — build_lines","text":"build_lines generates simple feature collection LINESTRINGs data.table. function accepts data.table relocation data, individual identifiers, sorting column projection. relocation data transformed LINESTRINGs individual , optionally, combination columns listed splitBy. Relocation data two columns representing X Y coordinates.","code":""},{"path":"https://docs.ropensci.org/spatsoc/reference/build_lines.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build Lines — build_lines","text":"","code":"build_lines(   DT = NULL,   projection = NULL,   id = NULL,   coords = NULL,   sortBy = NULL,   splitBy = NULL )"},{"path":"https://docs.ropensci.org/spatsoc/reference/build_lines.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build Lines — build_lines","text":"DT input data.table projection numeric character defining coordinate reference system passed sf::st_crs. example, either projection = \"EPSG:32736\" projection = 32736. id Character string ID column name coords Character vector X coordinate Y coordinate column names sortBy Character string date time column(s) sort rows . Must POSIXct. splitBy (optional) character string vector grouping column name(s) upon grouping calculated","code":""},{"path":"https://docs.ropensci.org/spatsoc/reference/build_lines.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build Lines — build_lines","text":"build_lines returns sf LINESTRING object line individual (optionally splitBy combination). Individuals (combinations individuals splitBy) less two relocations dropped since requires least two relocations build line.","code":""},{"path":[]},{"path":"https://docs.ropensci.org/spatsoc/reference/build_lines.html","id":"r-spatial-evolution","dir":"Reference","previous_headings":"","what":"R-spatial evolution","title":"Build Lines — build_lines","text":"Please note, spatsoc followed updates R spatial, GDAL PROJ handling projections, see https://r-spatial.org/r/2020/03/17/wkt.html. addition, build_lines previously used sp::SpatialLines updated use sf::st_as_sf sf::st_linestring according R-spatial evolution, see https://r-spatial.org/r/2022/04/12/evolution.html.","code":""},{"path":"https://docs.ropensci.org/spatsoc/reference/build_lines.html","id":"notes-on-arguments","dir":"Reference","previous_headings":"","what":"Notes on arguments","title":"Build Lines — build_lines","text":"projection argument expects numeric character defining coordinate reference system. example, UTM zone 36N (EPSG 32736), projection argument either projection = 'EPSG:32736' projection = 32736. See details sf::st_crs() https://spatialreference.org list EPSG codes. sortBy argument used order input DT creating sf LINESTRINGs. must column input DT type POSIXct ensure rows sorted date time. splitBy argument offers control building LINESTRINGs. input DT, multiple temporal groups (e.g.: years) example, can provide name column identifies build LINESTRINGs individual year. build_lines used group_lines grouping overlapping lines generated relocations.","code":""},{"path":[]},{"path":"https://docs.ropensci.org/spatsoc/reference/build_lines.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Build Lines — build_lines","text":"","code":"# Load data.table library(data.table) data.table::setDTthreads(1)  # Read example data DT <- fread(system.file(\"extdata\", \"DT.csv\", package = \"spatsoc\"))  # Cast the character column to POSIXct DT[, datetime := as.POSIXct(datetime, tz = 'UTC')] #>            ID        X       Y            datetime population #>        <char>    <num>   <num>              <POSc>      <int> #>     1:      A 715851.4 5505340 2016-11-01 00:00:54          1 #>     2:      A 715822.8 5505289 2016-11-01 02:01:22          1 #>     3:      A 715872.9 5505252 2016-11-01 04:01:24          1 #>     4:      A 715820.5 5505231 2016-11-01 06:01:05          1 #>     5:      A 715830.6 5505227 2016-11-01 08:01:11          1 #>    ---                                                        #> 14293:      J 700616.5 5509069 2017-02-28 14:00:54          1 #> 14294:      J 700622.6 5509065 2017-02-28 16:00:11          1 #> 14295:      J 700657.5 5509277 2017-02-28 18:00:55          1 #> 14296:      J 700610.3 5509269 2017-02-28 20:00:48          1 #> 14297:      J 700744.0 5508782 2017-02-28 22:00:39          1  # EPSG code for example data utm <- 32736  # Build lines for each individual lines <- build_lines(DT, projection = utm, id = 'ID', coords = c('X', 'Y'),             sortBy = 'datetime')  # Build lines for each individual by year DT[, yr := year(datetime)] #>            ID        X       Y            datetime population    yr #>        <char>    <num>   <num>              <POSc>      <int> <int> #>     1:      A 715851.4 5505340 2016-11-01 00:00:54          1  2016 #>     2:      A 715822.8 5505289 2016-11-01 02:01:22          1  2016 #>     3:      A 715872.9 5505252 2016-11-01 04:01:24          1  2016 #>     4:      A 715820.5 5505231 2016-11-01 06:01:05          1  2016 #>     5:      A 715830.6 5505227 2016-11-01 08:01:11          1  2016 #>    ---                                                              #> 14293:      J 700616.5 5509069 2017-02-28 14:00:54          1  2017 #> 14294:      J 700622.6 5509065 2017-02-28 16:00:11          1  2017 #> 14295:      J 700657.5 5509277 2017-02-28 18:00:55          1  2017 #> 14296:      J 700610.3 5509269 2017-02-28 20:00:48          1  2017 #> 14297:      J 700744.0 5508782 2017-02-28 22:00:39          1  2017 lines <- build_lines(DT, projection = utm, id = 'ID', coords = c('X', 'Y'),             sortBy = 'datetime', splitBy = 'yr')"},{"path":"https://docs.ropensci.org/spatsoc/reference/build_polys.html","id":null,"dir":"Reference","previous_headings":"","what":"Build Polygons — build_polys","title":"Build Polygons — build_polys","text":"build_polys generates simple feature collection POLYGONs data.table. function accepts data.table relocation data, individual identifiers, projection, home range type parameters. relocation data transformed POLYGONs using either adehabitatHR::mcp adehabitatHR::kernelUD individual , optionally, combination columns listed splitBy. Relocation data two columns representing X Y coordinates.","code":""},{"path":"https://docs.ropensci.org/spatsoc/reference/build_polys.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Build Polygons — build_polys","text":"","code":"build_polys(   DT = NULL,   projection = NULL,   hrType = NULL,   hrParams = NULL,   id = NULL,   coords = NULL,   splitBy = NULL,   spPts = NULL )"},{"path":"https://docs.ropensci.org/spatsoc/reference/build_polys.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Build Polygons — build_polys","text":"DT input data.table projection numeric character defining coordinate reference system passed sf::st_crs. example, either projection = \"EPSG:32736\" projection = 32736. hrType type HR estimation, either 'mcp' 'kernel' hrParams named list parameters adehabitatHR functions id Character string ID column name coords Character vector X coordinate Y coordinate column names splitBy (optional) character string vector grouping column name(s) upon grouping calculated spPts alternatively, provide solely SpatialPointsDataFrame one column representing ID point, specified adehabitatHR::mcp adehabitatHR::kernelUD","code":""},{"path":"https://docs.ropensci.org/spatsoc/reference/build_polys.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Build Polygons — build_polys","text":"build_polys returns simple feature collection POLYGONs individual (optionally splitBy combination). error returned hrParams match arguments respective hrType  adehabitatHR function.","code":""},{"path":"https://docs.ropensci.org/spatsoc/reference/build_polys.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Build Polygons — build_polys","text":"group_polys uses build_polys grouping overlapping polygons created relocations.","code":""},{"path":"https://docs.ropensci.org/spatsoc/reference/build_polys.html","id":"r-spatial-evolution","dir":"Reference","previous_headings":"","what":"R-spatial evolution","title":"Build Polygons — build_polys","text":"Please note, spatsoc followed updates R spatial, GDAL PROJ handling projections, see  details https://r-spatial.org/r/2020/03/17/wkt.html. addition, build_polys previously used sp::SpatialPoints updated use sf::st_as_sf according R-spatial evolution, see https://r-spatial.org/r/2022/04/12/evolution.html.","code":""},{"path":"https://docs.ropensci.org/spatsoc/reference/build_polys.html","id":"notes-on-arguments","dir":"Reference","previous_headings":"","what":"Notes on arguments","title":"Build Polygons — build_polys","text":"DT must data.table. data data.frame, can convert reference using data.table::setDT. id, coords (optional splitBy) arguments expect names respective columns DT correspond individual identifier, X Y coordinates, additional grouping columns. projection argument expects character string numeric defining coordinate reference system passed sf::st_crs. example, UTM zone 36S (EPSG 32736), projection argument projection = \"EPSG:32736\" projection = 32736. See https://spatialreference.org list EPSG codes. hrType must either one \"kernel\" \"mcp\". hrParams must named list arguments matching adehabitatHR::kernelUD adehabitatHR::getverticeshr adehabitatHR::mcp. splitBy argument offers control building POLYGONs. DT, multiple temporal groups (e.g.: years) example, can provide name column identifies build POLYGONs individual year.","code":""},{"path":[]},{"path":"https://docs.ropensci.org/spatsoc/reference/build_polys.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Build Polygons — build_polys","text":"","code":"# Load data.table library(data.table) data.table::setDTthreads(1)  # Read example data DT <- fread(system.file(\"extdata\", \"DT.csv\", package = \"spatsoc\"))  # Cast the character column to POSIXct DT[, datetime := as.POSIXct(datetime, tz = 'UTC')] #>            ID        X       Y            datetime population #>        <char>    <num>   <num>              <POSc>      <int> #>     1:      A 715851.4 5505340 2016-11-01 00:00:54          1 #>     2:      A 715822.8 5505289 2016-11-01 02:01:22          1 #>     3:      A 715872.9 5505252 2016-11-01 04:01:24          1 #>     4:      A 715820.5 5505231 2016-11-01 06:01:05          1 #>     5:      A 715830.6 5505227 2016-11-01 08:01:11          1 #>    ---                                                        #> 14293:      J 700616.5 5509069 2017-02-28 14:00:54          1 #> 14294:      J 700622.6 5509065 2017-02-28 16:00:11          1 #> 14295:      J 700657.5 5509277 2017-02-28 18:00:55          1 #> 14296:      J 700610.3 5509269 2017-02-28 20:00:48          1 #> 14297:      J 700744.0 5508782 2017-02-28 22:00:39          1  # EPSG code for example data utm <- 32736  # Build polygons for each individual using kernelUD and getverticeshr build_polys(DT, projection = utm, hrType = 'kernel',             hrParams = list(grid = 60, percent = 95),             id = 'ID', coords = c('X', 'Y')) #> Simple feature collection with 10 features and 2 fields #> Geometry type: MULTIPOLYGON #> Dimension:     XY #> Bounding box:  xmin: 691964.9 ymin: 5489527 xmax: 717689.4 ymax: 5516125 #> Projected CRS: +proj=utm +zone=36 +south +datum=WGS84 +units=m +no_defs #>   ID      area                       geometry #> A  A 192345367 MULTIPOLYGON (((693628 5506... #> B  B  17316394 MULTIPOLYGON (((703312.2 55... #> C  C 151238156 MULTIPOLYGON (((694712.6 55... #> D  D  16127640 MULTIPOLYGON (((694883.4 54... #> E  E  75190273 MULTIPOLYGON (((694705.4 55... #> F  F 115041937 MULTIPOLYGON (((694898.6 55... #> G  G  23395212 MULTIPOLYGON (((702963.8 55... #> H  H 101217169 MULTIPOLYGON (((692020.5 55... #> I  I 176667205 MULTIPOLYGON (((694732 5505... #> J  J 192475536 MULTIPOLYGON (((693703 5506...  # Build polygons for each individual by year DT[, yr := year(datetime)] #>            ID        X       Y            datetime population    yr #>        <char>    <num>   <num>              <POSc>      <int> <int> #>     1:      A 715851.4 5505340 2016-11-01 00:00:54          1  2016 #>     2:      A 715822.8 5505289 2016-11-01 02:01:22          1  2016 #>     3:      A 715872.9 5505252 2016-11-01 04:01:24          1  2016 #>     4:      A 715820.5 5505231 2016-11-01 06:01:05          1  2016 #>     5:      A 715830.6 5505227 2016-11-01 08:01:11          1  2016 #>    ---                                                              #> 14293:      J 700616.5 5509069 2017-02-28 14:00:54          1  2017 #> 14294:      J 700622.6 5509065 2017-02-28 16:00:11          1  2017 #> 14295:      J 700657.5 5509277 2017-02-28 18:00:55          1  2017 #> 14296:      J 700610.3 5509269 2017-02-28 20:00:48          1  2017 #> 14297:      J 700744.0 5508782 2017-02-28 22:00:39          1  2017 build_polys(DT, projection = utm, hrType = 'mcp',             hrParams = list(percent = 95),             id = 'ID', coords = c('X', 'Y'), splitBy = 'yr') #> Simple feature collection with 20 features and 2 fields #> Geometry type: POLYGON #> Dimension:     XY #> Bounding box:  xmin: 693394.8 ymin: 5490131 xmax: 715229.7 ymax: 5514806 #> Projected CRS: +proj=utm +zone=36 +south +datum=WGS84 +units=m +no_defs #> First 10 features: #>            ID      area                       geometry #> A-2016 A-2016 141208128 POLYGON ((707624.4 5514064,... #> A-2017 A-2017  68039437 POLYGON ((706582.7 5510383,... #> B-2016 B-2016   7851014 POLYGON ((699361.8 5511721,... #> B-2017 B-2017   9473597 POLYGON ((698473.2 5512210,... #> C-2016 C-2016  90247899 POLYGON ((711698.9 5506990,... #> C-2017 C-2017  64419958 POLYGON ((706580.1 5510401,... #> D-2016 D-2016   9478060 POLYGON ((698487.1 5492921,... #> D-2017 D-2017   7624492 POLYGON ((699711.3 5492069,... #> E-2016 E-2016  60086909 POLYGON ((707874.5 5507416,... #> E-2017 E-2017  23034604 POLYGON ((700660.7 5508942,..."},{"path":"https://docs.ropensci.org/spatsoc/reference/dyad_id.html","id":null,"dir":"Reference","previous_headings":"","what":"Dyad ID — dyad_id","title":"Dyad ID — dyad_id","text":"Generate dyad ID edge list generated edge_nn edge_dist.","code":""},{"path":"https://docs.ropensci.org/spatsoc/reference/dyad_id.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Dyad ID — dyad_id","text":"","code":"dyad_id(DT = NULL, id1 = NULL, id2 = NULL)"},{"path":"https://docs.ropensci.org/spatsoc/reference/dyad_id.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Dyad ID — dyad_id","text":"DT input data.table columns id1 id2, generated edge_dist edge_nn id1 ID1 column name generated edge_dist edge_nn id2 ID2 column name generated edge_dist edge_nn","code":""},{"path":"https://docs.ropensci.org/spatsoc/reference/dyad_id.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Dyad ID — dyad_id","text":"dyad_id returns input data.table appended \"dyadID\" column","code":""},{"path":"https://docs.ropensci.org/spatsoc/reference/dyad_id.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Dyad ID — dyad_id","text":"undirected edge identifier , example individuals B -B (reverse B -B). Internally sorts pastes id columns. details edge dyad vignette (progress).","code":""},{"path":"https://docs.ropensci.org/spatsoc/reference/dyad_id.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Dyad ID — dyad_id","text":"","code":"# Load data.table library(data.table) data.table::setDTthreads(1)  # Read example data DT <- fread(system.file(\"extdata\", \"DT.csv\", package = \"spatsoc\"))  # Cast the character column to POSIXct DT[, datetime := as.POSIXct(datetime, tz = 'UTC')] #>            ID        X       Y            datetime population #>        <char>    <num>   <num>              <POSc>      <int> #>     1:      A 715851.4 5505340 2016-11-01 00:00:54          1 #>     2:      A 715822.8 5505289 2016-11-01 02:01:22          1 #>     3:      A 715872.9 5505252 2016-11-01 04:01:24          1 #>     4:      A 715820.5 5505231 2016-11-01 06:01:05          1 #>     5:      A 715830.6 5505227 2016-11-01 08:01:11          1 #>    ---                                                        #> 14293:      J 700616.5 5509069 2017-02-28 14:00:54          1 #> 14294:      J 700622.6 5509065 2017-02-28 16:00:11          1 #> 14295:      J 700657.5 5509277 2017-02-28 18:00:55          1 #> 14296:      J 700610.3 5509269 2017-02-28 20:00:48          1 #> 14297:      J 700744.0 5508782 2017-02-28 22:00:39          1  # Temporal grouping group_times(DT, datetime = 'datetime', threshold = '20 minutes') #>            ID        X       Y            datetime population minutes timegroup #>        <char>    <num>   <num>              <POSc>      <int>   <int>     <int> #>     1:      A 715851.4 5505340 2016-11-01 00:00:54          1       0         1 #>     2:      A 715822.8 5505289 2016-11-01 02:01:22          1       0         2 #>     3:      A 715872.9 5505252 2016-11-01 04:01:24          1       0         3 #>     4:      A 715820.5 5505231 2016-11-01 06:01:05          1       0         4 #>     5:      A 715830.6 5505227 2016-11-01 08:01:11          1       0         5 #>    ---                                                                          #> 14293:      J 700616.5 5509069 2017-02-28 14:00:54          1       0      1393 #> 14294:      J 700622.6 5509065 2017-02-28 16:00:11          1       0      1394 #> 14295:      J 700657.5 5509277 2017-02-28 18:00:55          1       0      1440 #> 14296:      J 700610.3 5509269 2017-02-28 20:00:48          1       0      1395 #> 14297:      J 700744.0 5508782 2017-02-28 22:00:39          1       0      1396  # Edge list generation edges <- edge_dist(     DT,     threshold = 100,     id = 'ID',     coords = c('X', 'Y'),     timegroup = 'timegroup',     returnDist = TRUE,     fillNA = TRUE   )  # Generate dyad IDs dyad_id(edges, 'ID1', 'ID2') #> Key: <timegroup, ID1> #>        timegroup    ID1    ID2  distance dyadID #>            <int> <char> <char>     <num> <char> #>     1:         1      A   <NA>        NA   <NA> #>     2:         1      B      G  5.782904    B-G #>     3:         1      C   <NA>        NA   <NA> #>     4:         1      D   <NA>        NA   <NA> #>     5:         1      E      H 65.061671    E-H #>    ---                                          #> 22985:      1440      G   <NA>        NA   <NA> #> 22986:      1440      H   <NA>        NA   <NA> #> 22987:      1440      I      C  2.831071    C-I #> 22988:      1440      I      F  7.512922    F-I #> 22989:      1440      J   <NA>        NA   <NA>"},{"path":"https://docs.ropensci.org/spatsoc/reference/edge_dist.html","id":null,"dir":"Reference","previous_headings":"","what":"Distance based edge lists — edge_dist","title":"Distance based edge lists — edge_dist","text":"edge_dist returns edge lists defined spatial distance within user defined threshold. function accepts data.table relocation data, individual identifiers threshold argument. threshold argument used specify criteria distance points defines group. Relocation data two columns representing X Y coordinates.","code":""},{"path":"https://docs.ropensci.org/spatsoc/reference/edge_dist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Distance based edge lists — edge_dist","text":"","code":"edge_dist(   DT = NULL,   threshold,   id = NULL,   coords = NULL,   timegroup,   splitBy = NULL,   returnDist = FALSE,   fillNA = TRUE )"},{"path":"https://docs.ropensci.org/spatsoc/reference/edge_dist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Distance based edge lists — edge_dist","text":"DT input data.table threshold distance grouping points, units coordinates id Character string ID column name coords Character vector X coordinate Y coordinate column names timegroup timegroup field DT within grouping calculated splitBy (optional) character string vector grouping column name(s) upon grouping calculated returnDist boolean indicating distance individuals returned. FALSE (default), ID1, ID2 columns (timegroup, splitBy columns provided) returned. TRUE, another column \"distance\" returned indicating distance ID1 ID2. fillNA boolean indicating NAs returned individuals within threshold distance . TRUE, NAs returned. FALSE, edges individuals within threshold distance returned.","code":""},{"path":"https://docs.ropensci.org/spatsoc/reference/edge_dist.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Distance based edge lists — edge_dist","text":"edge_dist returns data.table columns ID1, ID2, timegroup (supplied) columns provided splitBy. 'returnDist' TRUE, column 'distance' returned indicating distance ID1 ID2. ID1 ID2 columns represent edges defined spatial (temporal group_times) thresholds.","code":""},{"path":"https://docs.ropensci.org/spatsoc/reference/edge_dist.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Distance based edge lists — edge_dist","text":"DT must data.table. data data.frame, can convert reference using data.table::setDT. id, coords timegroup (optional splitBy) arguments expect names column DT correspond individual identifier, X Y coordinates, timegroup (generated group_times) additional grouping columns. provided, threshold must provided units coordinates must larger 0. threshold NULL, distance individuals returned. coordinates must planar coordinates (e.g.: UTM). case UTM, threshold = 50 indicate 50m distance threshold. timegroup argument required define temporal groups within edges calculated. intended framework group rows temporally group_times spatially edge_dist. already calculated temporal groups without group_times, can pass column timegroup argument. Note expectation individual observed per timegroup. Caution accidentally including huge numbers rows within timegroups can overload machine since pairwise distances calculated within timegroup. splitBy argument offers control grouping. within DT, multiple populations, subgroups distinct parts, can provide name column identifies splitBy. edge_dist consider rows within splitBy subgroup.","code":""},{"path":[]},{"path":"https://docs.ropensci.org/spatsoc/reference/edge_dist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Distance based edge lists — edge_dist","text":"","code":"# Load data.table library(data.table) data.table::setDTthreads(1)  # Read example data DT <- fread(system.file(\"extdata\", \"DT.csv\", package = \"spatsoc\"))  # Cast the character column to POSIXct DT[, datetime := as.POSIXct(datetime, tz = 'UTC')] #>            ID        X       Y            datetime population #>        <char>    <num>   <num>              <POSc>      <int> #>     1:      A 715851.4 5505340 2016-11-01 00:00:54          1 #>     2:      A 715822.8 5505289 2016-11-01 02:01:22          1 #>     3:      A 715872.9 5505252 2016-11-01 04:01:24          1 #>     4:      A 715820.5 5505231 2016-11-01 06:01:05          1 #>     5:      A 715830.6 5505227 2016-11-01 08:01:11          1 #>    ---                                                        #> 14293:      J 700616.5 5509069 2017-02-28 14:00:54          1 #> 14294:      J 700622.6 5509065 2017-02-28 16:00:11          1 #> 14295:      J 700657.5 5509277 2017-02-28 18:00:55          1 #> 14296:      J 700610.3 5509269 2017-02-28 20:00:48          1 #> 14297:      J 700744.0 5508782 2017-02-28 22:00:39          1  # Temporal grouping group_times(DT, datetime = 'datetime', threshold = '20 minutes') #>            ID        X       Y            datetime population minutes timegroup #>        <char>    <num>   <num>              <POSc>      <int>   <int>     <int> #>     1:      A 715851.4 5505340 2016-11-01 00:00:54          1       0         1 #>     2:      A 715822.8 5505289 2016-11-01 02:01:22          1       0         2 #>     3:      A 715872.9 5505252 2016-11-01 04:01:24          1       0         3 #>     4:      A 715820.5 5505231 2016-11-01 06:01:05          1       0         4 #>     5:      A 715830.6 5505227 2016-11-01 08:01:11          1       0         5 #>    ---                                                                          #> 14293:      J 700616.5 5509069 2017-02-28 14:00:54          1       0      1393 #> 14294:      J 700622.6 5509065 2017-02-28 16:00:11          1       0      1394 #> 14295:      J 700657.5 5509277 2017-02-28 18:00:55          1       0      1440 #> 14296:      J 700610.3 5509269 2017-02-28 20:00:48          1       0      1395 #> 14297:      J 700744.0 5508782 2017-02-28 22:00:39          1       0      1396  # Edge list generation edges <- edge_dist(     DT,     threshold = 100,     id = 'ID',     coords = c('X', 'Y'),     timegroup = 'timegroup',     returnDist = TRUE,     fillNA = TRUE   )"},{"path":"https://docs.ropensci.org/spatsoc/reference/edge_nn.html","id":null,"dir":"Reference","previous_headings":"","what":"Nearest neighbour based edge lists — edge_nn","title":"Nearest neighbour based edge lists — edge_nn","text":"edge_nn returns edge lists defined nearest neighbour. function accepts data.table relocation data, individual identifiers threshold argument. threshold argument used specify criteria distance points defines group. Relocation data two columns representing X Y coordinates.","code":""},{"path":"https://docs.ropensci.org/spatsoc/reference/edge_nn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Nearest neighbour based edge lists — edge_nn","text":"","code":"edge_nn(   DT = NULL,   id = NULL,   coords = NULL,   timegroup,   splitBy = NULL,   threshold = NULL,   returnDist = FALSE )"},{"path":"https://docs.ropensci.org/spatsoc/reference/edge_nn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Nearest neighbour based edge lists — edge_nn","text":"DT input data.table id Character string ID column name coords Character vector X coordinate Y coordinate column names timegroup timegroup field DT within grouping calculated splitBy (optional) character string vector grouping column name(s) upon grouping calculated threshold (optional) spatial distance threshold set maximum distance individual neighbour. returnDist boolean indicating distance individuals returned. FALSE (default), ID, NN columns (timegroup, splitBy columns provided) returned. TRUE, another column \"distance\" returned indicating distance ID NN.","code":""},{"path":"https://docs.ropensci.org/spatsoc/reference/edge_nn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Nearest neighbour based edge lists — edge_nn","text":"edge_nn returns data.table  three columns: timegroup, ID NN. 'returnDist' TRUE, column 'distance' returned indicating distance ID NN. ID NN columns represent edges defined nearest neighbours (temporal thresholds group_times). individual alone timegroup splitBy, neighbours within threshold distance, assigned NA nearest neighbour.","code":""},{"path":"https://docs.ropensci.org/spatsoc/reference/edge_nn.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Nearest neighbour based edge lists — edge_nn","text":"DT must data.table. data data.frame, can convert reference using data.table::setDT. id, coords, timegroup  (optional splitBy) arguments expect names column DT correspond individual identifier, X Y coordinates, timegroup (generated group_times) additional grouping columns. threshold must provided units coordinates. threshold must larger 0. coordinates must planar coordinates (e.g.: UTM). case UTM, threshold = 50 indicate 50m distance threshold. timegroup argument required define temporal groups within edge nearest neighbours calculated. intended framework group rows temporally group_times spatially edge_nn. already calculated temporal groups without group_times, can pass column timegroup argument. Note expectation individual observed per timegroup. Caution accidentally including huge numbers rows within timegroups can overload machine since pairwise distances calculated within timegroup. splitBy argument offers control grouping. within DT, multiple populations, subgroups distinct parts, can provide name column identifies splitBy. edge_nn consider rows within splitBy subgroup.","code":""},{"path":[]},{"path":"https://docs.ropensci.org/spatsoc/reference/edge_nn.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Nearest neighbour based edge lists — edge_nn","text":"","code":"# Load data.table library(data.table) data.table::setDTthreads(1)  # Read example data DT <- fread(system.file(\"extdata\", \"DT.csv\", package = \"spatsoc\"))  # Select only individuals A, B, C for this example DT <- DT[ID %in% c('A', 'B', 'C')]  # Cast the character column to POSIXct DT[, datetime := as.POSIXct(datetime, tz = 'UTC')] #>           ID        X       Y            datetime population #>       <char>    <num>   <num>              <POSc>      <int> #>    1:      A 715851.4 5505340 2016-11-01 00:00:54          1 #>    2:      A 715822.8 5505289 2016-11-01 02:01:22          1 #>    3:      A 715872.9 5505252 2016-11-01 04:01:24          1 #>    4:      A 715820.5 5505231 2016-11-01 06:01:05          1 #>    5:      A 715830.6 5505227 2016-11-01 08:01:11          1 #>   ---                                                        #> 4265:      C 702093.6 5510180 2017-02-28 14:00:44          1 #> 4266:      C 702086.0 5510183 2017-02-28 16:00:42          1 #> 4267:      C 702961.8 5509447 2017-02-28 18:00:53          1 #> 4268:      C 703130.4 5509528 2017-02-28 20:00:54          1 #> 4269:      C 702872.3 5508531 2017-02-28 22:00:18          1  # Temporal grouping group_times(DT, datetime = 'datetime', threshold = '20 minutes') #>           ID        X       Y            datetime population minutes timegroup #>       <char>    <num>   <num>              <POSc>      <int>   <int>     <int> #>    1:      A 715851.4 5505340 2016-11-01 00:00:54          1       0         1 #>    2:      A 715822.8 5505289 2016-11-01 02:01:22          1       0         2 #>    3:      A 715872.9 5505252 2016-11-01 04:01:24          1       0         3 #>    4:      A 715820.5 5505231 2016-11-01 06:01:05          1       0         4 #>    5:      A 715830.6 5505227 2016-11-01 08:01:11          1       0         5 #>   ---                                                                          #> 4265:      C 702093.6 5510180 2017-02-28 14:00:44          1       0      1393 #> 4266:      C 702086.0 5510183 2017-02-28 16:00:42          1       0      1394 #> 4267:      C 702961.8 5509447 2017-02-28 18:00:53          1       0      1440 #> 4268:      C 703130.4 5509528 2017-02-28 20:00:54          1       0      1395 #> 4269:      C 702872.3 5508531 2017-02-28 22:00:18          1       0      1396  # Edge list generation edges <- edge_nn(DT, id = 'ID', coords = c('X', 'Y'),         timegroup = 'timegroup')  # Edge list generation using maximum distance threshold edges <- edge_nn(DT, id = 'ID', coords = c('X', 'Y'),         timegroup = 'timegroup', threshold = 100)  # Edge list generation, returning distance between nearest neighbours edge_nn(DT, id = 'ID', coords = c('X', 'Y'),         timegroup = 'timegroup', threshold = 100,         returnDist = TRUE) #>       timegroup     ID     NN distance #>           <int> <char> <char>    <num> #>    1:         1      A   <NA>       NA #>    2:         1      B   <NA>       NA #>    3:         1      C   <NA>       NA #>    4:         2      A   <NA>       NA #>    5:         2      B   <NA>       NA #>   ---                                  #> 4265:      1438      C   <NA>       NA #> 4266:      1439      B   <NA>       NA #> 4267:      1439      C   <NA>       NA #> 4268:      1440      B   <NA>       NA #> 4269:      1440      C   <NA>       NA"},{"path":"https://docs.ropensci.org/spatsoc/reference/get_gbi.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate group by individual matrix — get_gbi","title":"Generate group by individual matrix — get_gbi","text":"get_gbi generates group individual matrix. function accepts data.table individual identifiers group column. group individual matrix can used build network using asnipe::get_network.","code":""},{"path":"https://docs.ropensci.org/spatsoc/reference/get_gbi.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate group by individual matrix — get_gbi","text":"","code":"get_gbi(DT = NULL, group = \"group\", id = NULL)"},{"path":"https://docs.ropensci.org/spatsoc/reference/get_gbi.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate group by individual matrix — get_gbi","text":"DT input data.table group Character string group column (generated one spatsoc's spatial grouping functions) id Character string ID column name","code":""},{"path":"https://docs.ropensci.org/spatsoc/reference/get_gbi.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate group by individual matrix — get_gbi","text":"get_gbi returns group individual matrix (columns represent individuals rows represent groups). Note get_gbi identical function turning outputs spatsoc social networks asnipe::get_group_by_individual efficient thanks data.table::dcast.","code":""},{"path":"https://docs.ropensci.org/spatsoc/reference/get_gbi.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Generate group by individual matrix — get_gbi","text":"DT must data.table. data data.frame, can convert reference using data.table::setDT. group argument expects name column corresponds integer group identifier (generated spatsoc's grouping functions). id argument expects name column corresponds individual identifier.","code":""},{"path":[]},{"path":"https://docs.ropensci.org/spatsoc/reference/get_gbi.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate group by individual matrix — get_gbi","text":"","code":"# Load data.table library(data.table) data.table::setDTthreads(1)  # Read example data DT <- fread(system.file(\"extdata\", \"DT.csv\", package = \"spatsoc\"))  # Cast the character column to POSIXct DT[, datetime := as.POSIXct(datetime, tz = 'UTC')] #>            ID        X       Y            datetime population #>        <char>    <num>   <num>              <POSc>      <int> #>     1:      A 715851.4 5505340 2016-11-01 00:00:54          1 #>     2:      A 715822.8 5505289 2016-11-01 02:01:22          1 #>     3:      A 715872.9 5505252 2016-11-01 04:01:24          1 #>     4:      A 715820.5 5505231 2016-11-01 06:01:05          1 #>     5:      A 715830.6 5505227 2016-11-01 08:01:11          1 #>    ---                                                        #> 14293:      J 700616.5 5509069 2017-02-28 14:00:54          1 #> 14294:      J 700622.6 5509065 2017-02-28 16:00:11          1 #> 14295:      J 700657.5 5509277 2017-02-28 18:00:55          1 #> 14296:      J 700610.3 5509269 2017-02-28 20:00:48          1 #> 14297:      J 700744.0 5508782 2017-02-28 22:00:39          1 DT[, yr := year(datetime)] #>            ID        X       Y            datetime population    yr #>        <char>    <num>   <num>              <POSc>      <int> <int> #>     1:      A 715851.4 5505340 2016-11-01 00:00:54          1  2016 #>     2:      A 715822.8 5505289 2016-11-01 02:01:22          1  2016 #>     3:      A 715872.9 5505252 2016-11-01 04:01:24          1  2016 #>     4:      A 715820.5 5505231 2016-11-01 06:01:05          1  2016 #>     5:      A 715830.6 5505227 2016-11-01 08:01:11          1  2016 #>    ---                                                              #> 14293:      J 700616.5 5509069 2017-02-28 14:00:54          1  2017 #> 14294:      J 700622.6 5509065 2017-02-28 16:00:11          1  2017 #> 14295:      J 700657.5 5509277 2017-02-28 18:00:55          1  2017 #> 14296:      J 700610.3 5509269 2017-02-28 20:00:48          1  2017 #> 14297:      J 700744.0 5508782 2017-02-28 22:00:39          1  2017  # EPSG code for example data utm <- 'EPSG:32736'  group_polys(DT, area = FALSE, hrType = 'mcp',             hrParams = list(percent = 95),             projection = utm, id = 'ID', coords = c('X', 'Y'),             splitBy = 'yr') #>            ID        X       Y            datetime population    yr group #>        <char>    <num>   <num>              <POSc>      <int> <int> <int> #>     1:      A 715851.4 5505340 2016-11-01 00:00:54          1  2016     1 #>     2:      A 715822.8 5505289 2016-11-01 02:01:22          1  2016     1 #>     3:      A 715872.9 5505252 2016-11-01 04:01:24          1  2016     1 #>     4:      A 715820.5 5505231 2016-11-01 06:01:05          1  2016     1 #>     5:      A 715830.6 5505227 2016-11-01 08:01:11          1  2016     1 #>    ---                                                                    #> 14293:      J 700616.5 5509069 2017-02-28 14:00:54          1  2017     2 #> 14294:      J 700622.6 5509065 2017-02-28 16:00:11          1  2017     2 #> 14295:      J 700657.5 5509277 2017-02-28 18:00:55          1  2017     2 #> 14296:      J 700610.3 5509269 2017-02-28 20:00:48          1  2017     2 #> 14297:      J 700744.0 5508782 2017-02-28 22:00:39          1  2017     2  gbiMtrx <- get_gbi(DT = DT, group = 'group', id = 'ID')"},{"path":"https://docs.ropensci.org/spatsoc/reference/group_lines.html","id":null,"dir":"Reference","previous_headings":"","what":"Group Lines — group_lines","title":"Group Lines — group_lines","text":"group_lines groups rows spatial groups generating LINESTRINGs grouping based spatial intersection. function accepts data.table relocation data, individual identifiers distance threshold. relocation data transformed sf LINESTRINGs using build_lines intersecting LINESTRINGs grouped. threshold argument used specify distance criteria grouping. Relocation data two columns representing X Y coordinates.","code":""},{"path":"https://docs.ropensci.org/spatsoc/reference/group_lines.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Group Lines — group_lines","text":"","code":"group_lines(   DT = NULL,   threshold = NULL,   projection = NULL,   id = NULL,   coords = NULL,   timegroup = NULL,   sortBy = NULL,   splitBy = NULL,   sfLines = NULL )"},{"path":"https://docs.ropensci.org/spatsoc/reference/group_lines.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Group Lines — group_lines","text":"DT input data.table threshold width buffer around lines units projection. Use threshold = 0 compare intersection without buffering. projection numeric character defining coordinate reference system passed sf::st_crs. example, either projection = \"EPSG:32736\" projection = 32736. id Character string ID column name coords Character vector X coordinate Y coordinate column names timegroup timegroup field DT within grouping calculated sortBy Character string date time column(s) sort rows . Must POSIXct. splitBy (optional) character string vector grouping column name(s) upon grouping calculated sfLines Alternatively providing DT, provide simple feature LINESTRING object generated sf package. id argument required provide identifier matching LINESTRING. sfLines object provided, groups calculated timegroup splitBy.","code":""},{"path":"https://docs.ropensci.org/spatsoc/reference/group_lines.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Group Lines — group_lines","text":"group_lines returns input DT appended \"group\" column. column represents spatial (timegroup provided - spatiotemporal) group calculated intersecting lines. grouping functions,  actual value group arbitrary represents identity given group 1 individuals assigned group. data reordered, group may change, contents group . message returned column named \"group\" already exists input DT, overwritten.","code":""},{"path":[]},{"path":"https://docs.ropensci.org/spatsoc/reference/group_lines.html","id":"r-spatial-evolution","dir":"Reference","previous_headings":"","what":"R-spatial evolution","title":"Group Lines — group_lines","text":"Please note, spatsoc followed updates R spatial, GDAL PROJ handling projections, see https://r-spatial.org/r/2020/03/17/wkt.html. addition, group_lines (build_lines) previously used sp::SpatialLines, rgeos::gIntersects, rgeos::gBuffer updated use sf::st_as_sf, sf::st_linestring, sf::st_intersects, sf::st_buffer according R-spatial evolution, see https://r-spatial.org/r/2022/04/12/evolution.html.","code":""},{"path":"https://docs.ropensci.org/spatsoc/reference/group_lines.html","id":"notes-on-arguments","dir":"Reference","previous_headings":"","what":"Notes on arguments","title":"Group Lines — group_lines","text":"DT must data.table. data data.frame, can convert reference using data.table::setDT. id, coords, sortBy (optional timegroup splitBy) arguments expect names respective columns DT correspond individual identifier, X Y coordinates, sorting, timegroup (generated group_times) additional grouping columns. projection argument expects numeric character defining coordinate reference system. example, UTM zone 36N (EPSG 32736), projection argument either projection = 'EPSG:32736' projection = 32736. See details sf::st_crs() https://spatialreference.org list EPSG codes. sortBy argument used order input DT creating sf LINESTRINGs. must column input DT type POSIXct ensure rows sorted date time. threshold must provided units coordinates. threshold can equal 0 strict overlap intended, otherwise value greater 0. coordinates must planar coordinates (e.g.: UTM). case UTM, threshold = 50 indicate 50m distance threshold. timegroup argument optional, recommended pair group_times. intended framework group rows temporally group_times spatially group_lines (group_pts, group_polys). group_lines, pick relevant group_times threshold '1 day' '7 days' informed study species, system question. splitBy argument offers control building LINESTRINGs. input DT, multiple temporal groups (e.g.: years) example, can provide name column identifies build LINESTRINGs individual year. grouping performed group_lines consider rows within splitBy subgroup.","code":""},{"path":[]},{"path":"https://docs.ropensci.org/spatsoc/reference/group_lines.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Group Lines — group_lines","text":"","code":"# Load data.table library(data.table) data.table::setDTthreads(1)  # Read example data DT <- fread(system.file(\"extdata\", \"DT.csv\", package = \"spatsoc\"))  # Subset only individuals A, B, and C DT <- DT[ID %in% c('A', 'B', 'C')]  # Cast the character column to POSIXct DT[, datetime := as.POSIXct(datetime, tz = 'UTC')] #>           ID        X       Y            datetime population #>       <char>    <num>   <num>              <POSc>      <int> #>    1:      A 715851.4 5505340 2016-11-01 00:00:54          1 #>    2:      A 715822.8 5505289 2016-11-01 02:01:22          1 #>    3:      A 715872.9 5505252 2016-11-01 04:01:24          1 #>    4:      A 715820.5 5505231 2016-11-01 06:01:05          1 #>    5:      A 715830.6 5505227 2016-11-01 08:01:11          1 #>   ---                                                        #> 4265:      C 702093.6 5510180 2017-02-28 14:00:44          1 #> 4266:      C 702086.0 5510183 2017-02-28 16:00:42          1 #> 4267:      C 702961.8 5509447 2017-02-28 18:00:53          1 #> 4268:      C 703130.4 5509528 2017-02-28 20:00:54          1 #> 4269:      C 702872.3 5508531 2017-02-28 22:00:18          1  # EPSG code for example data utm <- 32736  group_lines(DT, threshold = 50, projection = utm, sortBy = 'datetime',             id = 'ID', coords = c('X', 'Y')) #>           ID        X       Y            datetime population group #>       <char>    <num>   <num>              <POSc>      <int> <num> #>    1:      A 715851.4 5505340 2016-11-01 00:00:54          1     1 #>    2:      A 715822.8 5505289 2016-11-01 02:01:22          1     1 #>    3:      A 715872.9 5505252 2016-11-01 04:01:24          1     1 #>    4:      A 715820.5 5505231 2016-11-01 06:01:05          1     1 #>    5:      A 715830.6 5505227 2016-11-01 08:01:11          1     1 #>   ---                                                              #> 4265:      C 702093.6 5510180 2017-02-28 14:00:44          1     1 #> 4266:      C 702086.0 5510183 2017-02-28 16:00:42          1     1 #> 4267:      C 702961.8 5509447 2017-02-28 18:00:53          1     1 #> 4268:      C 703130.4 5509528 2017-02-28 20:00:54          1     1 #> 4269:      C 702872.3 5508531 2017-02-28 22:00:18          1     1  ## Daily movement tracks # Temporal grouping group_times(DT, datetime = 'datetime', threshold = '1 day') #>           ID        X       Y            datetime population group timegroup #>       <char>    <num>   <num>              <POSc>      <int> <num>     <int> #>    1:      A 715851.4 5505340 2016-11-01 00:00:54          1     1         1 #>    2:      A 715822.8 5505289 2016-11-01 02:01:22          1     1         1 #>    3:      A 715872.9 5505252 2016-11-01 04:01:24          1     1         1 #>    4:      A 715820.5 5505231 2016-11-01 06:01:05          1     1         1 #>    5:      A 715830.6 5505227 2016-11-01 08:01:11          1     1         1 #>   ---                                                                        #> 4265:      C 702093.6 5510180 2017-02-28 14:00:44          1     1       120 #> 4266:      C 702086.0 5510183 2017-02-28 16:00:42          1     1       120 #> 4267:      C 702961.8 5509447 2017-02-28 18:00:53          1     1       120 #> 4268:      C 703130.4 5509528 2017-02-28 20:00:54          1     1       120 #> 4269:      C 702872.3 5508531 2017-02-28 22:00:18          1     1       120  # Subset only first 50 days DT <- DT[timegroup < 25]  # Spatial grouping group_lines(DT, threshold = 50, projection = utm,             id = 'ID', coords = c('X', 'Y'),             timegroup = 'timegroup', sortBy = 'datetime') #> group column will be overwritten by this function #>          ID        X       Y            datetime population timegroup group #>      <char>    <num>   <num>              <POSc>      <int>     <int> <int> #>   1:      A 715851.4 5505340 2016-11-01 00:00:54          1         1     1 #>   2:      A 715822.8 5505289 2016-11-01 02:01:22          1         1     1 #>   3:      A 715872.9 5505252 2016-11-01 04:01:24          1         1     1 #>   4:      A 715820.5 5505231 2016-11-01 06:01:05          1         1     1 #>   5:      A 715830.6 5505227 2016-11-01 08:01:11          1         1     1 #>  ---                                                                        #> 857:      C 710769.9 5507380 2016-11-24 14:00:55          1        24    63 #> 858:      C 710930.9 5507290 2016-11-24 16:00:26          1        24    63 #> 859:      C 711004.1 5507310 2016-11-24 18:00:49          1        24    63 #> 860:      C 711274.1 5507269 2016-11-24 20:00:24          1        24    63 #> 861:      C 711054.3 5506998 2016-11-24 22:00:41          1        24    63  ## Daily movement tracks by population group_lines(DT, threshold = 50, projection = utm,             id = 'ID', coords = c('X', 'Y'),             timegroup = 'timegroup', sortBy = 'datetime',             splitBy = 'population') #> group column will be overwritten by this function #>          ID        X       Y            datetime population timegroup group #>      <char>    <num>   <num>              <POSc>      <int>     <int> <int> #>   1:      A 715851.4 5505340 2016-11-01 00:00:54          1         1     1 #>   2:      A 715822.8 5505289 2016-11-01 02:01:22          1         1     1 #>   3:      A 715872.9 5505252 2016-11-01 04:01:24          1         1     1 #>   4:      A 715820.5 5505231 2016-11-01 06:01:05          1         1     1 #>   5:      A 715830.6 5505227 2016-11-01 08:01:11          1         1     1 #>  ---                                                                        #> 857:      C 710769.9 5507380 2016-11-24 14:00:55          1        24    63 #> 858:      C 710930.9 5507290 2016-11-24 16:00:26          1        24    63 #> 859:      C 711004.1 5507310 2016-11-24 18:00:49          1        24    63 #> 860:      C 711274.1 5507269 2016-11-24 20:00:24          1        24    63 #> 861:      C 711054.3 5506998 2016-11-24 22:00:41          1        24    63"},{"path":"https://docs.ropensci.org/spatsoc/reference/group_polys.html","id":null,"dir":"Reference","previous_headings":"","what":"Group Polygons — group_polys","title":"Group Polygons — group_polys","text":"group_polys groups rows spatial groups overlapping polygons (home ranges). function accepts data.table relocation data, individual identifiers area argument.  relocation data transformed home range POLYGONs using build_polys() adehabitatHR::mcp adehabitatHR::kernelUD. area argument FALSE, group_polys returns grouping calculated spatial overlap. area argument TRUE, group_polys returns area area proportion overlap. Relocation data two columns representing X Y coordinates.","code":""},{"path":"https://docs.ropensci.org/spatsoc/reference/group_polys.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Group Polygons — group_polys","text":"","code":"group_polys(   DT = NULL,   area = NULL,   hrType = NULL,   hrParams = NULL,   projection = NULL,   id = NULL,   coords = NULL,   splitBy = NULL,   sfPolys = NULL )"},{"path":"https://docs.ropensci.org/spatsoc/reference/group_polys.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Group Polygons — group_polys","text":"DT input data.table area boolean indicating either overlap group (FALSE) area proportion overlap (TRUE) hrType type HR estimation, either 'mcp' 'kernel' hrParams named list parameters adehabitatHR functions projection numeric character defining coordinate reference system passed sf::st_crs. example, either projection = \"EPSG:32736\" projection = 32736. id Character string ID column name coords Character vector X coordinate Y coordinate column names splitBy (optional) character string vector grouping column name(s) upon grouping calculated sfPolys Alternatively, provide solely simple features object POLYGONs MULTIPOLYGONs. sfPolys provided, id required splitBy used.","code":""},{"path":"https://docs.ropensci.org/spatsoc/reference/group_polys.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Group Polygons — group_polys","text":"area FALSE, group_polys returns input DT appended group column. grouping functions,  actual value group arbitrary represents identity given group 1 individuals assigned group. data reordered, group may change, contents group . area TRUE, group_polys returns proportional area overlap data.table. case, ID refers focal individual total area compared overlapping area ID2. area FALSE, message returned column named group already exists input DT, overwritten. Along changes follow R-spatial evolution, group_polys also now returns area proportion overlap units explicitly specified units package.","code":""},{"path":[]},{"path":"https://docs.ropensci.org/spatsoc/reference/group_polys.html","id":"r-spatial-evolution","dir":"Reference","previous_headings":"","what":"R-spatial evolution","title":"Group Polygons — group_polys","text":"Please note, spatsoc followed updates R spatial, GDAL PROJ handling projections, see  details https://r-spatial.org/r/2020/03/17/wkt.html. addition, group_polys previously used rgeos::gIntersection, rgeos::gIntersects rgeos::gArea updated use sf::st_intersects, sf::st_intersection sf::st_area according R-spatial evolution, see https://r-spatial.org/r/2022/04/12/evolution.html.","code":""},{"path":"https://docs.ropensci.org/spatsoc/reference/group_polys.html","id":"notes-on-arguments","dir":"Reference","previous_headings":"","what":"Notes on arguments","title":"Group Polygons — group_polys","text":"DT must data.table. data data.frame, can convert reference using data.table::setDT(). id, coords (optional splitBy) arguments expect names respective columns DT correspond individual identifier, X Y coordinates, additional grouping columns. projection argument expects character string numeric defining coordinate reference system passed sf::st_crs. example, UTM zone 36S (EPSG 32736), projection argument projection = \"EPSG:32736\" projection = 32736. See https://spatialreference.org list EPSG codes. hrType must either one \"kernel\" \"mcp\". hrParams must named list arguments matching adehabitatHR::kernelUD() adehabitatHR::mcp(). splitBy argument offers control grouping. within DT, multiple populations, subgroups distinct parts, can provide name column identifies splitBy. grouping performed group_polys consider rows within splitBy subgroup.","code":""},{"path":[]},{"path":"https://docs.ropensci.org/spatsoc/reference/group_polys.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Group Polygons — group_polys","text":"","code":"# Load data.table library(data.table) data.table::setDTthreads(1)  # Read example data DT <- fread(system.file(\"extdata\", \"DT.csv\", package = \"spatsoc\"))  # Cast the character column to POSIXct DT[, datetime := as.POSIXct(datetime, tz = 'UTC')] #>            ID        X       Y            datetime population #>        <char>    <num>   <num>              <POSc>      <int> #>     1:      A 715851.4 5505340 2016-11-01 00:00:54          1 #>     2:      A 715822.8 5505289 2016-11-01 02:01:22          1 #>     3:      A 715872.9 5505252 2016-11-01 04:01:24          1 #>     4:      A 715820.5 5505231 2016-11-01 06:01:05          1 #>     5:      A 715830.6 5505227 2016-11-01 08:01:11          1 #>    ---                                                        #> 14293:      J 700616.5 5509069 2017-02-28 14:00:54          1 #> 14294:      J 700622.6 5509065 2017-02-28 16:00:11          1 #> 14295:      J 700657.5 5509277 2017-02-28 18:00:55          1 #> 14296:      J 700610.3 5509269 2017-02-28 20:00:48          1 #> 14297:      J 700744.0 5508782 2017-02-28 22:00:39          1  # EPSG code for example data utm <- 32736  group_polys(DT, area = FALSE, hrType = 'mcp',             hrParams = list(percent = 95), projection = utm,             id = 'ID', coords = c('X', 'Y')) #>            ID        X       Y            datetime population group #>        <char>    <num>   <num>              <POSc>      <int> <int> #>     1:      A 715851.4 5505340 2016-11-01 00:00:54          1     1 #>     2:      A 715822.8 5505289 2016-11-01 02:01:22          1     1 #>     3:      A 715872.9 5505252 2016-11-01 04:01:24          1     1 #>     4:      A 715820.5 5505231 2016-11-01 06:01:05          1     1 #>     5:      A 715830.6 5505227 2016-11-01 08:01:11          1     1 #>    ---                                                              #> 14293:      J 700616.5 5509069 2017-02-28 14:00:54          1     1 #> 14294:      J 700622.6 5509065 2017-02-28 16:00:11          1     1 #> 14295:      J 700657.5 5509277 2017-02-28 18:00:55          1     1 #> 14296:      J 700610.3 5509269 2017-02-28 20:00:48          1     1 #> 14297:      J 700744.0 5508782 2017-02-28 22:00:39          1     1  areaDT <- group_polys(DT, area = TRUE, hrType = 'mcp',                       hrParams = list(percent = 95), projection = utm,                       id = 'ID', coords = c('X', 'Y')) print(areaDT) #>         ID1    ID2            area           proportion #>      <char> <char>         <units>              <units> #>   1:      A      A 145142204 [m^2] 100.000000 [percent] #>   2:      B      A   9731424 [m^2]  91.676823 [percent] #>   3:      C      A 110069503 [m^2]  99.961124 [percent] #>   4:      E      A  60057115 [m^2]  96.286738 [percent] #>   5:      F      A  87608610 [m^2]  93.849807 [percent] #>   6:      G      A  12182087 [m^2]  93.204824 [percent] #>   7:      H      A  61089896 [m^2]  75.352709 [percent] #>   8:      I      A 125675100 [m^2]  99.939817 [percent] #>   9:      J      A 101995862 [m^2]  76.979490 [percent] #>  10:      A      B   9731424 [m^2]   6.704751 [percent] #>  11:      B      B  10614922 [m^2] 100.000000 [percent] #>  12:      C      B   9554942 [m^2]   8.677452 [percent] #>  13:      E      B   9906676 [m^2]  15.882906 [percent] #>  14:      F      B   9509693 [m^2]  10.187159 [percent] #>  15:      G      B  10573553 [m^2]  80.897972 [percent] #>  16:      H      B  10145705 [m^2]  12.514448 [percent] #>  17:      I      B   9711953 [m^2]   7.723175 [percent] #>  18:      J      B  10384186 [m^2]   7.837272 [percent] #>  19:      A      C 110069503 [m^2]  75.835629 [percent] #>  20:      B      C   9554942 [m^2]  90.014246 [percent] #>  21:      C      C 110112310 [m^2] 100.000000 [percent] #>  22:      E      C  54497018 [m^2]  87.372497 [percent] #>  23:      F      C  82198072 [m^2]  88.053825 [percent] #>  24:      G      C  12003003 [m^2]  91.834655 [percent] #>  25:      H      C  55343937 [m^2]  68.265227 [percent] #>  26:      I      C 109925578 [m^2]  87.415423 [percent] #>  27:      J      C  88882259 [m^2]  67.082241 [percent] #>  28:      D      D  11667275 [m^2] 100.000000 [percent] #>  29:      A      E  60057115 [m^2]  41.378120 [percent] #>  30:      B      E   9906676 [m^2]  93.327825 [percent] #>  31:      C      E  54497018 [m^2]  49.492212 [percent] #>  32:      E      E  62373195 [m^2] 100.000000 [percent] #>  33:      F      E  45418786 [m^2]  48.654399 [percent] #>  34:      G      E  12323593 [m^2]  94.287482 [percent] #>  35:      H      E  61624267 [m^2]  76.011842 [percent] #>  36:      I      E  56208280 [m^2]  44.698155 [percent] #>  37:      J      E  61868357 [m^2]  46.693998 [percent] #>  38:      A      F  87608610 [m^2]  60.360535 [percent] #>  39:      B      F   9509693 [m^2]  89.587964 [percent] #>  40:      C      F  82198072 [m^2]  74.649303 [percent] #>  41:      E      F  45418786 [m^2]  72.817795 [percent] #>  42:      F      F  93349803 [m^2] 100.000000 [percent] #>  43:      G      F  11958427 [m^2]  91.493607 [percent] #>  44:      H      F  46287984 [m^2]  57.094957 [percent] #>  45:      I      F  83430540 [m^2]  66.345942 [percent] #>  46:      J      F  61213465 [m^2]  46.199730 [percent] #>  47:      A      G  12182087 [m^2]   8.393208 [percent] #>  48:      B      G  10573553 [m^2]  99.610273 [percent] #>  49:      C      G  12003003 [m^2]  10.900691 [percent] #>  50:      E      G  12323593 [m^2]  19.757836 [percent] #>  51:      F      G  11958427 [m^2]  12.810340 [percent] #>  52:      G      G  13070233 [m^2] 100.000000 [percent] #>  53:      H      G  12563547 [m^2]  15.496790 [percent] #>  54:      I      G  12162428 [m^2]   9.671850 [percent] #>  55:      J      G  12803712 [m^2]   9.663365 [percent] #>  56:      A      H  61089896 [m^2]  42.089685 [percent] #>  57:      B      H  10145705 [m^2]  95.579643 [percent] #>  58:      C      H  55343937 [m^2]  50.261353 [percent] #>  59:      E      H  61624267 [m^2]  98.799279 [percent] #>  60:      F      H  46287984 [m^2]  49.585518 [percent] #>  61:      G      H  12563547 [m^2]  96.123361 [percent] #>  62:      H      H  81071930 [m^2] 100.000000 [percent] #>  63:      I      H  57514743 [m^2]  45.737086 [percent] #>  64:      J      H  66161291 [m^2]  49.934010 [percent] #>  65:      A      I 125675100 [m^2]  86.587565 [percent] #>  66:      B      I   9711953 [m^2]  91.493392 [percent] #>  67:      C      I 109925578 [m^2]  99.830416 [percent] #>  68:      E      I  56208280 [m^2]  90.116082 [percent] #>  69:      F      I  83430540 [m^2]  89.374094 [percent] #>  70:      G      I  12162428 [m^2]  93.054406 [percent] #>  71:      H      I  57514743 [m^2]  70.942856 [percent] #>  72:      I      I 125750781 [m^2] 100.000000 [percent] #>  73:      J      I  93471355 [m^2]  70.545776 [percent] #>  74:      A      J 101995862 [m^2]  70.273056 [percent] #>  75:      B      J  10384186 [m^2]  97.826298 [percent] #>  76:      C      J  88882259 [m^2]  80.719639 [percent] #>  77:      E      J  61868357 [m^2]  99.190617 [percent] #>  78:      F      J  61213465 [m^2]  65.574284 [percent] #>  79:      G      J  12803712 [m^2]  97.960856 [percent] #>  80:      H      J  66161291 [m^2]  81.608136 [percent] #>  81:      I      J  93471355 [m^2]  74.330636 [percent] #>  82:      J      J 132497451 [m^2] 100.000000 [percent] #>  83:      A      D         0 [m^2]   0.000000 [percent] #>  84:      B      D         0 [m^2]   0.000000 [percent] #>  85:      C      D         0 [m^2]   0.000000 [percent] #>  86:      D      A         0 [m^2]   0.000000 [percent] #>  87:      D      B         0 [m^2]   0.000000 [percent] #>  88:      D      C         0 [m^2]   0.000000 [percent] #>  89:      D      E         0 [m^2]   0.000000 [percent] #>  90:      D      F         0 [m^2]   0.000000 [percent] #>  91:      D      G         0 [m^2]   0.000000 [percent] #>  92:      D      H         0 [m^2]   0.000000 [percent] #>  93:      D      I         0 [m^2]   0.000000 [percent] #>  94:      D      J         0 [m^2]   0.000000 [percent] #>  95:      E      D         0 [m^2]   0.000000 [percent] #>  96:      F      D         0 [m^2]   0.000000 [percent] #>  97:      G      D         0 [m^2]   0.000000 [percent] #>  98:      H      D         0 [m^2]   0.000000 [percent] #>  99:      I      D         0 [m^2]   0.000000 [percent] #> 100:      J      D         0 [m^2]   0.000000 [percent] #>         ID1    ID2            area           proportion"},{"path":"https://docs.ropensci.org/spatsoc/reference/group_pts.html","id":null,"dir":"Reference","previous_headings":"","what":"Group Points — group_pts","title":"Group Points — group_pts","text":"group_pts groups rows spatial groups. function accepts data.table relocation data, individual identifiers threshold argument. threshold argument used specify criteria distance points defines group. Relocation data two columns representing X Y coordinates.","code":""},{"path":"https://docs.ropensci.org/spatsoc/reference/group_pts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Group Points — group_pts","text":"","code":"group_pts(   DT = NULL,   threshold = NULL,   id = NULL,   coords = NULL,   timegroup,   splitBy = NULL )"},{"path":"https://docs.ropensci.org/spatsoc/reference/group_pts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Group Points — group_pts","text":"DT input data.table threshold distance grouping points, units coordinates id Character string ID column name coords Character vector X coordinate Y coordinate column names timegroup timegroup field DT within grouping calculated splitBy (optional) character string vector grouping column name(s) upon grouping calculated","code":""},{"path":"https://docs.ropensci.org/spatsoc/reference/group_pts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Group Points — group_pts","text":"group_pts returns input DT appended group column. column represents spatialtemporal group. grouping functions,  actual value group arbitrary represents identity given group 1 individuals assigned group. data reordered, group may change, contents group . message returned column named group already exists input DT, overwritten.","code":""},{"path":"https://docs.ropensci.org/spatsoc/reference/group_pts.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Group Points — group_pts","text":"DT must data.table. data data.frame, can convert reference using data.table::setDT. id, coords, timegroup (optional splitBy) arguments expect names column DT correspond individual identifier, X Y coordinates, timegroup (typically generated group_times) additional grouping columns. threshold must provided units coordinates. threshold must larger 0. coordinates must planar coordinates (e.g.: UTM). case UTM, threshold = 50 indicate 50m distance threshold. timegroup argument required define temporal groups within spatial groups calculated. intended framework group rows temporally group_times spatially group_pts (group_lines, group_polys). already calculated temporal groups without group_times, can pass column timegroup argument. Note expectation individual observed per timegroup. Caution accidentally including huge numbers rows within timegroups can overload machine since pairwise distances calculated within timegroup. splitBy argument offers control grouping. within DT, multiple populations, subgroups distinct parts, can provide name column identifies splitBy. grouping performed group_pts consider rows within splitBy subgroup.","code":""},{"path":[]},{"path":"https://docs.ropensci.org/spatsoc/reference/group_pts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Group Points — group_pts","text":"","code":"# Load data.table library(data.table) data.table::setDTthreads(1)  # Read example data DT <- fread(system.file(\"extdata\", \"DT.csv\", package = \"spatsoc\"))  # Select only individuals A, B, C for this example DT <- DT[ID %in% c('A', 'B', 'C')]  # Cast the character column to POSIXct DT[, datetime := as.POSIXct(datetime, tz = 'UTC')] #>           ID        X       Y            datetime population #>       <char>    <num>   <num>              <POSc>      <int> #>    1:      A 715851.4 5505340 2016-11-01 00:00:54          1 #>    2:      A 715822.8 5505289 2016-11-01 02:01:22          1 #>    3:      A 715872.9 5505252 2016-11-01 04:01:24          1 #>    4:      A 715820.5 5505231 2016-11-01 06:01:05          1 #>    5:      A 715830.6 5505227 2016-11-01 08:01:11          1 #>   ---                                                        #> 4265:      C 702093.6 5510180 2017-02-28 14:00:44          1 #> 4266:      C 702086.0 5510183 2017-02-28 16:00:42          1 #> 4267:      C 702961.8 5509447 2017-02-28 18:00:53          1 #> 4268:      C 703130.4 5509528 2017-02-28 20:00:54          1 #> 4269:      C 702872.3 5508531 2017-02-28 22:00:18          1  # Temporal grouping group_times(DT, datetime = 'datetime', threshold = '20 minutes') #>           ID        X       Y            datetime population minutes timegroup #>       <char>    <num>   <num>              <POSc>      <int>   <int>     <int> #>    1:      A 715851.4 5505340 2016-11-01 00:00:54          1       0         1 #>    2:      A 715822.8 5505289 2016-11-01 02:01:22          1       0         2 #>    3:      A 715872.9 5505252 2016-11-01 04:01:24          1       0         3 #>    4:      A 715820.5 5505231 2016-11-01 06:01:05          1       0         4 #>    5:      A 715830.6 5505227 2016-11-01 08:01:11          1       0         5 #>   ---                                                                          #> 4265:      C 702093.6 5510180 2017-02-28 14:00:44          1       0      1393 #> 4266:      C 702086.0 5510183 2017-02-28 16:00:42          1       0      1394 #> 4267:      C 702961.8 5509447 2017-02-28 18:00:53          1       0      1440 #> 4268:      C 703130.4 5509528 2017-02-28 20:00:54          1       0      1395 #> 4269:      C 702872.3 5508531 2017-02-28 22:00:18          1       0      1396  # Spatial grouping with timegroup group_pts(DT, threshold = 5, id = 'ID',           coords = c('X', 'Y'), timegroup = 'timegroup') #>           ID        X       Y            datetime population minutes timegroup #>       <char>    <num>   <num>              <POSc>      <int>   <int>     <int> #>    1:      A 715851.4 5505340 2016-11-01 00:00:54          1       0         1 #>    2:      A 715822.8 5505289 2016-11-01 02:01:22          1       0         2 #>    3:      A 715872.9 5505252 2016-11-01 04:01:24          1       0         3 #>    4:      A 715820.5 5505231 2016-11-01 06:01:05          1       0         4 #>    5:      A 715830.6 5505227 2016-11-01 08:01:11          1       0         5 #>   ---                                                                          #> 4265:      C 702093.6 5510180 2017-02-28 14:00:44          1       0      1393 #> 4266:      C 702086.0 5510183 2017-02-28 16:00:42          1       0      1394 #> 4267:      C 702961.8 5509447 2017-02-28 18:00:53          1       0      1440 #> 4268:      C 703130.4 5509528 2017-02-28 20:00:54          1       0      1395 #> 4269:      C 702872.3 5508531 2017-02-28 22:00:18          1       0      1396 #>       group #>       <int> #>    1:     1 #>    2:     2 #>    3:     3 #>    4:     4 #>    5:     5 #>   ---       #> 4265:  4228 #> 4266:  4229 #> 4267:  4230 #> 4268:  4231 #> 4269:  4232  # Spatial grouping with timegroup and splitBy on population group_pts(DT, threshold = 5, id = 'ID', coords = c('X', 'Y'),          timegroup = 'timegroup', splitBy = 'population') #> group column will be overwritten by this function #>           ID        X       Y            datetime population minutes timegroup #>       <char>    <num>   <num>              <POSc>      <int>   <int>     <int> #>    1:      A 715851.4 5505340 2016-11-01 00:00:54          1       0         1 #>    2:      A 715822.8 5505289 2016-11-01 02:01:22          1       0         2 #>    3:      A 715872.9 5505252 2016-11-01 04:01:24          1       0         3 #>    4:      A 715820.5 5505231 2016-11-01 06:01:05          1       0         4 #>    5:      A 715830.6 5505227 2016-11-01 08:01:11          1       0         5 #>   ---                                                                          #> 4265:      C 702093.6 5510180 2017-02-28 14:00:44          1       0      1393 #> 4266:      C 702086.0 5510183 2017-02-28 16:00:42          1       0      1394 #> 4267:      C 702961.8 5509447 2017-02-28 18:00:53          1       0      1440 #> 4268:      C 703130.4 5509528 2017-02-28 20:00:54          1       0      1395 #> 4269:      C 702872.3 5508531 2017-02-28 22:00:18          1       0      1396 #>       group #>       <int> #>    1:     1 #>    2:     2 #>    3:     3 #>    4:     4 #>    5:     5 #>   ---       #> 4265:  4228 #> 4266:  4229 #> 4267:  4230 #> 4268:  4231 #> 4269:  4232"},{"path":"https://docs.ropensci.org/spatsoc/reference/group_times.html","id":null,"dir":"Reference","previous_headings":"","what":"Group Times — group_times","title":"Group Times — group_times","text":"group_times groups rows time groups. function accepts date time formatted data threshold argument. threshold argument used specify time window within rows grouped.","code":""},{"path":"https://docs.ropensci.org/spatsoc/reference/group_times.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Group Times — group_times","text":"","code":"group_times(DT = NULL, datetime = NULL, threshold = NULL)"},{"path":"https://docs.ropensci.org/spatsoc/reference/group_times.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Group Times — group_times","text":"DT input data.table datetime name date time column(s). either 1 POSIXct 2 IDate ITime. e.g.: 'datetime' c('idate', 'itime') threshold threshold grouping times. e.g.: '2 hours', '10 minutes', etc. provided, times matched exactly. Note provided threshold must expected format: '## unit'","code":""},{"path":"https://docs.ropensci.org/spatsoc/reference/group_times.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Group Times — group_times","text":"group_times returns input DT appended timegroup column additional temporal grouping columns help investigate, troubleshoot interpret timegroup. actual value timegroup arbitrary represents identity given timegroup 1 individuals assigned . data reordered, group may change, contents group . temporal grouping columns added depend threshold provided: threshold unit minutes: \"minutes\" column added identifying nearest minute group row. threshold unit hours: \"hours\" column added identifying nearest hour group row. threshold unit days: \"block\" columns added identifying multiday block row. message returned columns already exist input DT, overwritten.","code":""},{"path":"https://docs.ropensci.org/spatsoc/reference/group_times.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Group Times — group_times","text":"DT must data.table. data data.frame, can convert reference using data.table::setDT. datetime argument expects name column DT type POSIXct name two columns DT type IDate ITime. threshold must provided units minutes, hours days. character string start integer followed unit, separated space. interpreted terms 24 hours poses following limitations: minutes, hours days fractional minutes must divide evenly 60 minutes must exceed 60 minutes, hours nearer next day, grouped hours must divide evenly 24 multi-day blocks divide range days, else blocks may length addition, threshold considered fixed window throughout time series rows grouped nearest interval. threshold NULL, rows grouped using datetime column directly.","code":""},{"path":[]},{"path":"https://docs.ropensci.org/spatsoc/reference/group_times.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Group Times — group_times","text":"","code":"# Load data.table library(data.table) data.table::setDTthreads(1)  # Read example data DT <- fread(system.file(\"extdata\", \"DT.csv\", package = \"spatsoc\"))  # Cast the character column to POSIXct DT[, datetime := as.POSIXct(datetime, tz = 'UTC')] #>            ID        X       Y            datetime population #>        <char>    <num>   <num>              <POSc>      <int> #>     1:      A 715851.4 5505340 2016-11-01 00:00:54          1 #>     2:      A 715822.8 5505289 2016-11-01 02:01:22          1 #>     3:      A 715872.9 5505252 2016-11-01 04:01:24          1 #>     4:      A 715820.5 5505231 2016-11-01 06:01:05          1 #>     5:      A 715830.6 5505227 2016-11-01 08:01:11          1 #>    ---                                                        #> 14293:      J 700616.5 5509069 2017-02-28 14:00:54          1 #> 14294:      J 700622.6 5509065 2017-02-28 16:00:11          1 #> 14295:      J 700657.5 5509277 2017-02-28 18:00:55          1 #> 14296:      J 700610.3 5509269 2017-02-28 20:00:48          1 #> 14297:      J 700744.0 5508782 2017-02-28 22:00:39          1  group_times(DT, datetime = 'datetime', threshold = '5 minutes') #>            ID        X       Y            datetime population minutes timegroup #>        <char>    <num>   <num>              <POSc>      <int>   <int>     <int> #>     1:      A 715851.4 5505340 2016-11-01 00:00:54          1       0         1 #>     2:      A 715822.8 5505289 2016-11-01 02:01:22          1       0         2 #>     3:      A 715872.9 5505252 2016-11-01 04:01:24          1       0         3 #>     4:      A 715820.5 5505231 2016-11-01 06:01:05          1       0         4 #>     5:      A 715830.6 5505227 2016-11-01 08:01:11          1       0         5 #>    ---                                                                          #> 14293:      J 700616.5 5509069 2017-02-28 14:00:54          1       0      1393 #> 14294:      J 700622.6 5509065 2017-02-28 16:00:11          1       0      1394 #> 14295:      J 700657.5 5509277 2017-02-28 18:00:55          1       0      1449 #> 14296:      J 700610.3 5509269 2017-02-28 20:00:48          1       0      1395 #> 14297:      J 700744.0 5508782 2017-02-28 22:00:39          1       0      1396  group_times(DT, datetime = 'datetime', threshold = '2 hours') #> minutes, timegroup columns found in input DT and will be overwritten by this function #>            ID        X       Y            datetime population hours timegroup #>        <char>    <num>   <num>              <POSc>      <int> <int>     <int> #>     1:      A 715851.4 5505340 2016-11-01 00:00:54          1     0         1 #>     2:      A 715822.8 5505289 2016-11-01 02:01:22          1     2         2 #>     3:      A 715872.9 5505252 2016-11-01 04:01:24          1     4         3 #>     4:      A 715820.5 5505231 2016-11-01 06:01:05          1     6         4 #>     5:      A 715830.6 5505227 2016-11-01 08:01:11          1     8         5 #>    ---                                                                        #> 14293:      J 700616.5 5509069 2017-02-28 14:00:54          1    14      1393 #> 14294:      J 700622.6 5509065 2017-02-28 16:00:11          1    16      1394 #> 14295:      J 700657.5 5509277 2017-02-28 18:00:55          1    18      1440 #> 14296:      J 700610.3 5509269 2017-02-28 20:00:48          1    20      1395 #> 14297:      J 700744.0 5508782 2017-02-28 22:00:39          1    22      1396  group_times(DT, datetime = 'datetime', threshold = '10 days') #> hours, timegroup columns found in input DT and will be overwritten by this function #> Warning: the minimum and maximum days in DT are not evenly divisible by the provided block length #>            ID        X       Y            datetime population block timegroup #>        <char>    <num>   <num>              <POSc>      <int> <int>     <int> #>     1:      A 715851.4 5505340 2016-11-01 00:00:54          1    31         1 #>     2:      A 715822.8 5505289 2016-11-01 02:01:22          1    31         1 #>     3:      A 715872.9 5505252 2016-11-01 04:01:24          1    31         1 #>     4:      A 715820.5 5505231 2016-11-01 06:01:05          1    31         1 #>     5:      A 715830.6 5505227 2016-11-01 08:01:11          1    31         1 #>    ---                                                                        #> 14293:      J 700616.5 5509069 2017-02-28 14:00:54          1     6        13 #> 14294:      J 700622.6 5509065 2017-02-28 16:00:11          1     6        13 #> 14295:      J 700657.5 5509277 2017-02-28 18:00:55          1     6        13 #> 14296:      J 700610.3 5509269 2017-02-28 20:00:48          1     6        13 #> 14297:      J 700744.0 5508782 2017-02-28 22:00:39          1     6        13"},{"path":"https://docs.ropensci.org/spatsoc/reference/randomizations.html","id":null,"dir":"Reference","previous_headings":"","what":"Data-stream randomizations — randomizations","title":"Data-stream randomizations — randomizations","text":"randomizations performs data-stream social network randomization. function accepts data.table relocation data, individual identifiers randomization type. data.table randomized either using step daily -individual methods, within-individual daily trajectory method described Spiegel et al. (2016).","code":""},{"path":"https://docs.ropensci.org/spatsoc/reference/randomizations.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Data-stream randomizations — randomizations","text":"","code":"randomizations(   DT = NULL,   type = NULL,   id = NULL,   group = NULL,   coords = NULL,   datetime = NULL,   splitBy = NULL,   iterations = NULL )"},{"path":"https://docs.ropensci.org/spatsoc/reference/randomizations.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Data-stream randomizations — randomizations","text":"DT input data.table type one 'daily', 'step' 'trajectory' - see details id Character string ID column name group generated spatial grouping functions - see details coords Character vector X coordinate Y coordinate column names datetime field used providing date time time group - see details splitBy List fields DT split randomization process iterations number iterations randomize","code":""},{"path":"https://docs.ropensci.org/spatsoc/reference/randomizations.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Data-stream randomizations — randomizations","text":"randomizations returns random date time random id along original DT, depending randomization type. length returned data.table original number rows multiplied number iterations + 1. example, 3 iterations return 4x - one observed three randomized. Two columns always returned: observed - rows represent observed (TRUE/FALSE) iteration - iteration rows (0 observed) addition, depending randomization type, random ID random date time columns returned: step - randomID time step daily - randomID day jul indicating julian day trajectory - random date time (\"random\" prefixed datetime argument), observed jul randomJul indicating random day relocations swapped .","code":""},{"path":"https://docs.ropensci.org/spatsoc/reference/randomizations.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Data-stream randomizations — randomizations","text":"DT must data.table. data data.frame, can convert reference using data.table::setDT. Three randomization types provided: step - randomizes identities relocations individuals within time step. daily - randomizes identities relocations individuals within day. trajectory - randomizes daily trajectories within individuals (Spiegel et al. 2016). Depending type, datetime must certain format: step - datetime integer group created group_times daily - datetime POSIXct format trajectory - datetime POSIXct format id, datetime,  (optional splitBy) arguments expect names respective columns DT correspond individual identifier, date time, additional grouping columns. coords argument required type \"trajectory\", since coordinates required recalculating spatial groups group_pts, group_lines group_polys. Please note data extends multiple years, column indicating year provided splitBy argument. ensure randomizations occur within year. group argument expected type 'step' 'daily'. example, using data.table::year: iterations set 1 provided. Take caution large value iterations large input DT.","code":"DT[, yr := year(datetime)] randomizations(DT, type = 'step', id = 'ID', datetime = 'timegroup', splitBy = 'yr')"},{"path":"https://docs.ropensci.org/spatsoc/reference/randomizations.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Data-stream randomizations — randomizations","text":"doi:10.1111/2041-210X.12553","code":""},{"path":[]},{"path":"https://docs.ropensci.org/spatsoc/reference/randomizations.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Data-stream randomizations — randomizations","text":"","code":"# Load data.table library(data.table) data.table::setDTthreads(1)  # Read example data DT <- fread(system.file(\"extdata\", \"DT.csv\", package = \"spatsoc\"))  # Select only individuals A, B, C for this example DT <- DT[ID %in% c('A', 'B', 'C')]  # Date time columns DT[, datetime := as.POSIXct(datetime)] #>           ID        X       Y            datetime population #>       <char>    <num>   <num>              <POSc>      <int> #>    1:      A 715851.4 5505340 2016-11-01 00:00:54          1 #>    2:      A 715822.8 5505289 2016-11-01 02:01:22          1 #>    3:      A 715872.9 5505252 2016-11-01 04:01:24          1 #>    4:      A 715820.5 5505231 2016-11-01 06:01:05          1 #>    5:      A 715830.6 5505227 2016-11-01 08:01:11          1 #>   ---                                                        #> 4265:      C 702093.6 5510180 2017-02-28 14:00:44          1 #> 4266:      C 702086.0 5510183 2017-02-28 16:00:42          1 #> 4267:      C 702961.8 5509447 2017-02-28 18:00:53          1 #> 4268:      C 703130.4 5509528 2017-02-28 20:00:54          1 #> 4269:      C 702872.3 5508531 2017-02-28 22:00:18          1 DT[, yr := year(datetime)] #>           ID        X       Y            datetime population    yr #>       <char>    <num>   <num>              <POSc>      <int> <int> #>    1:      A 715851.4 5505340 2016-11-01 00:00:54          1  2016 #>    2:      A 715822.8 5505289 2016-11-01 02:01:22          1  2016 #>    3:      A 715872.9 5505252 2016-11-01 04:01:24          1  2016 #>    4:      A 715820.5 5505231 2016-11-01 06:01:05          1  2016 #>    5:      A 715830.6 5505227 2016-11-01 08:01:11          1  2016 #>   ---                                                              #> 4265:      C 702093.6 5510180 2017-02-28 14:00:44          1  2017 #> 4266:      C 702086.0 5510183 2017-02-28 16:00:42          1  2017 #> 4267:      C 702961.8 5509447 2017-02-28 18:00:53          1  2017 #> 4268:      C 703130.4 5509528 2017-02-28 20:00:54          1  2017 #> 4269:      C 702872.3 5508531 2017-02-28 22:00:18          1  2017  # Temporal grouping group_times(DT, datetime = 'datetime', threshold = '5 minutes') #>           ID        X       Y            datetime population    yr minutes #>       <char>    <num>   <num>              <POSc>      <int> <int>   <int> #>    1:      A 715851.4 5505340 2016-11-01 00:00:54          1  2016       0 #>    2:      A 715822.8 5505289 2016-11-01 02:01:22          1  2016       0 #>    3:      A 715872.9 5505252 2016-11-01 04:01:24          1  2016       0 #>    4:      A 715820.5 5505231 2016-11-01 06:01:05          1  2016       0 #>    5:      A 715830.6 5505227 2016-11-01 08:01:11          1  2016       0 #>   ---                                                                      #> 4265:      C 702093.6 5510180 2017-02-28 14:00:44          1  2017       0 #> 4266:      C 702086.0 5510183 2017-02-28 16:00:42          1  2017       0 #> 4267:      C 702961.8 5509447 2017-02-28 18:00:53          1  2017       0 #> 4268:      C 703130.4 5509528 2017-02-28 20:00:54          1  2017       0 #> 4269:      C 702872.3 5508531 2017-02-28 22:00:18          1  2017       0 #>       timegroup #>           <int> #>    1:         1 #>    2:         2 #>    3:         3 #>    4:         4 #>    5:         5 #>   ---           #> 4265:      1393 #> 4266:      1394 #> 4267:      1449 #> 4268:      1395 #> 4269:      1396  # Spatial grouping with timegroup group_pts(DT, threshold = 5, id = 'ID', coords = c('X', 'Y'), timegroup = 'timegroup') #>           ID        X       Y            datetime population    yr minutes #>       <char>    <num>   <num>              <POSc>      <int> <int>   <int> #>    1:      A 715851.4 5505340 2016-11-01 00:00:54          1  2016       0 #>    2:      A 715822.8 5505289 2016-11-01 02:01:22          1  2016       0 #>    3:      A 715872.9 5505252 2016-11-01 04:01:24          1  2016       0 #>    4:      A 715820.5 5505231 2016-11-01 06:01:05          1  2016       0 #>    5:      A 715830.6 5505227 2016-11-01 08:01:11          1  2016       0 #>   ---                                                                      #> 4265:      C 702093.6 5510180 2017-02-28 14:00:44          1  2017       0 #> 4266:      C 702086.0 5510183 2017-02-28 16:00:42          1  2017       0 #> 4267:      C 702961.8 5509447 2017-02-28 18:00:53          1  2017       0 #> 4268:      C 703130.4 5509528 2017-02-28 20:00:54          1  2017       0 #> 4269:      C 702872.3 5508531 2017-02-28 22:00:18          1  2017       0 #>       timegroup group #>           <int> <int> #>    1:         1     1 #>    2:         2     2 #>    3:         3     3 #>    4:         4     4 #>    5:         5     5 #>   ---                 #> 4265:      1393  4228 #> 4266:      1394  4229 #> 4267:      1449  4230 #> 4268:      1395  4231 #> 4269:      1396  4232  # Randomization: step randStep <- randomizations(     DT,     type = 'step',     id = 'ID',     group = 'group',     datetime = 'timegroup',     splitBy = 'yr',     iterations = 2 )  # Randomization: daily randDaily <- randomizations(     DT,     type = 'daily',     id = 'ID',     group = 'group',     datetime = 'datetime',     splitBy = 'yr',     iterations = 2 ) #> Warning: Unknown argument 'on' has been passed.  # Randomization: trajectory randTraj <- randomizations(     DT,     type = 'trajectory',     id = 'ID',     group = NULL,     coords = c('X', 'Y'),     datetime = 'datetime',     splitBy = 'yr',     iterations = 2 ) #> Warning: Unknown argument 'on' has been passed."},{"path":"https://docs.ropensci.org/spatsoc/reference/spatsoc.html","id":null,"dir":"Reference","previous_headings":"","what":"spatsoc — spatsoc","title":"spatsoc — spatsoc","text":"spatsoc R package detecting spatial temporal groups GPS relocations. can used convert GPS relocations gambit---group format build proximity-based social networks. addition, randomization function provides data-stream randomization methods suitable GPS data.","code":""},{"path":"https://docs.ropensci.org/spatsoc/reference/spatsoc.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"spatsoc — spatsoc","text":"spatsoc package provides one temporal grouping function: group_times three spatial grouping functions: group_pts group_lines group_polys two edge list generating functions: edge_dist edge_nn two social network functions: randomizations get_gbi","code":""},{"path":[]},{"path":"https://docs.ropensci.org/spatsoc/reference/spatsoc.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"spatsoc — spatsoc","text":"Maintainer: Alec L. Robitaille robit.alec@gmail.com (ORCID) Authors: Quinn Webber (ORCID) Eric Vander Wal (ORCID)","code":""}]
